






<!doctype html>

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/_static/spectre.css">
<link rel="stylesheet" href="/_static/pygments.css">
<link rel="stylesheet" href="/_static/style.css">

<link rel="alternate" type="application/atom+xml" title="Atom feed" href="/_feed/index.xml" />

<link rel="icon" href="/_static/xo-system-icon.svg">
<link rel="apple-touch-icon" href="/_static/xo-system-icon.svg">







<title>Limiting concurrency in Python asyncio; or, the story of async imap_unordered() - death and gravity</title>




<script>
/* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
function set_vh() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}
/* we do it once, now, *and* on every resize */
set_vh();
window.addEventListener('resize', set_vh);
</script>





<div class="main container grid-lg">


<header>
<nav>
<ul class="breadcrumb">

<li class="breadcrumb-item">
    <a href="/">death and gravity</a>
</li>

</ul>
</nav>

<h1 class="heading-noindex">Limiting concurrency in Python asyncio; or, the story of async imap_unordered()</h1>

<p class="text-gray text-nowrap">



<small>
<span class="tooltip" data-tooltip="published on 2023-01-23">January 2023</span>
∙ 12 minute read
∙
</small><span class="share-icons">
<a
    class="share-icon twitter"
    href="https://twitter.%63%6f%6d/%73%68%61%72%65?text=Limiting%20concurrency%20in%20Python%20asyncio%3B%20or%2C%20the%20story%20of%20async%20imap_unordered%28%29&url=https%3A//death.andgravity.com/asyncio-map-unordered&via=_andgravity"
>Twitter</a>
<a
    class="share-icon hacker-news"
    href="https://news.ycombinator.%63%6f%6d/submitlink?u=https%3A//death.andgravity.com/asyncio-map-unordered&t=Limiting%20concurrency%20in%20Python%20asyncio%3B%20or%2C%20the%20story%20of%20async%20imap_unordered%28%29"
>HN</a>
<a
    class="share-icon reddit"
    href="https://www.reddit.%63%6f%6d/%73%75%62%6d%69%74?url=https%3A//death.andgravity.com/asyncio-map-unordered&title=Limiting%20concurrency%20in%20Python%20asyncio%3B%20or%2C%20the%20story%20of%20async%20imap_unordered%28%29"
>Reddit</a>
</span>


</p>






</header>


<main class="content columns">
<div class="column col-sm-12 col-md-10 col-8">

<!-- TODO: rename this to limit-concurrency -->
<p>So, you're doing some async stuff, repeatedly. Many times.</p>
<p>Like, <strong>hundreds of thousands of times</strong>.</p>
<p>Maybe you're just scraping some data.</p>
<p>Maybe it's more complicated than that
– you're calling API one,
passing the result to API two,
and then saving the result of that.</p>
<p>Either way, it's probably a good idea to <em>not</em> do it all at once.
For one, it's not polite to the APIs you're calling.
For another, it'll load everything in memory, <em>all at once</em>.</p>
<p>In <strong>sync</strong> code,
you might use a <a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.dummy">thread pool</a> and <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered">imap_unordered()</a>:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">dummy</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">do_stuff</span><span class="p">,</span> <span class="n">things_to_do</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div>

<p>Here, concurrency is limited by the fixed number of threads.</p>
<p>How about <strong>async</strong> code?
In this article,
we'll examine a few different solutions,
comparing them along the way,
to find out which is best.</p>
<section class="admonition tip">
<p class="admonition-title">Tip</p>
<p>No, it's not <a href="#asyncio-semaphore">Semaphore</a>,
 despite what Stack Overflow may tell you.</p>
</section>
<section class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you're in a hurry – it's <a href="#asyncio-wait">wait()</a>.</p>
</section>
<details>
<summary>Contents</summary>
<section class="toc">
<ul>
<li><a href="#setup">Setup</a></li>
<li><a href="#asyncio-gather">asyncio.gather()</a></li>
<li><a href="#asyncio-semaphore">asyncio.Semaphore</a></li>
<li><a href="#asyncio-as-completed">asyncio.as_completed()</a></li>
<li><a href="#asyncio-queue">asyncio.Queue</a></li>
<li><a href="#aside-backpressure">Aside: backpressure</a></li>
<li><a href="#asyncio-wait">asyncio.wait()</a></li>
<li><a href="#async-iterators">Async iterators</a></li>
<li><a href="#exceptions">Exceptions</a></li>
</ul>
</section>
</details>
<h2 id="setup">Setup<span class="headerlink"> <a href="#setup" title="permalink">#</a></span></h2>
<p>To try things out more easily,
let's write a test harness of sorts.</p>
<!--
<details>
<summary>Imports:</summary>

.. literalinclude:: mo_00_serial.py
    :lines: 1-5

</details>
-->
<p>We start with a <code>map_unordered()</code>
that relies on a <code>limit_concurrency()</code> generator
to run awaitables from an iterable in parallel,
<code>limit</code> at a time:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">map_unordered</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="n">aws</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">limit_concurrency</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
</code></pre></div>
</td></tr></table>
<p>... except right now it does them one by one
(we'll get back to this later on):</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">limit_concurrency</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="n">aws</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">aw</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">yield</span> <span class="k">await</span> <span class="n">aw</span>
</code></pre></div>
</td></tr></table>
<p>To simulate work being done,
we use something that's almost like <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.sleep">asyncio.sleep()</a>:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">sleep</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="mi">1</span> <span class="o">/</span> <span class="n">i</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">i</span>
</code></pre></div>
</td></tr></table>
<p>We then use map_unordered() to sleep() concurrently
as directed by the script arguments,
printing timings along the way:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">async_main</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">map_unordered</span><span class="p">(</span><span class="n">sleep</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">: done&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">async_main</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">limit</span><span class="p">),</span> <span class="n">timeout</span><span class="p">))</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div>
</td></tr></table>
<p>We invoke the script with <code>python map_unordered.py LIMIT TIME...</code>, like so:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span>
<span class="go">0.0: done</span>
<span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2
<span class="go">0.1: 0.1</span>
<span class="go">0.3: 0.2</span>
<span class="go">0.3: done</span>
</code></pre></div>
<section class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you need a refresher on the lower level <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a> stuff we'll use,
 check out Hynek Schlawack's excellent
 <a href="https://hynek.me/articles/waiting-in-asyncio/">Waiting in asyncio</a>.</p>
</section>
<h2 id="asyncio-gather">asyncio.gather()<span class="headerlink"> <a href="#asyncio-gather" title="permalink">#</a></span></h2>
<p>In the <a href="https://docs.python.org/3/library/asyncio-task.html#running-tasks-concurrently">Running Tasks Concurrently</a> section of the asyncio docs,
we find <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather">asyncio.gather()</a>,
which runs multiple awaitables,
and returns a list of results.</p>
<p>We can use it to run <code>limit</code>-sized chunks of awaitables:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">limit_concurrency</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="n">aws</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">batch</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">limit</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">batch</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">batch</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">result</span>
</code></pre></div>
</td></tr></table>
<p>This seems to work:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2
<span class="go">0.2: 0.1</span>
<span class="go">0.2: 0.2</span>
<span class="go">0.2: done</span>
</code></pre></div>
<p>... except:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2 .2 .1
<span class="go">0.2: 0.1</span>
<span class="go">0.2: 0.2</span>
<span class="go">0.4: 0.2</span>
<span class="go">0.4: 0.1</span>
<span class="go">0.4: done</span>
</code></pre></div>
<p>... those should fit in 0.3 seconds:</p>
<div class="highlight code-container"><pre class="code" data-lang="Text only"><span></span><code>| sleep(.1) |       sleep(.2)       |
|       sleep(.2)       | sleep(.1) |
</code></pre></div>
<p>It looks like we're waiting for all tasks in a batch to finish,
instead of allowing any of the next tasks to run:</p>
<div class="highlight code-container"><pre class="code" data-lang="Text only"><span></span><code>| sleep(.1) |...........|       sleep(.2)       |
|       sleep(.2)       | sleep(.1) |...........|
</code></pre></div>
<h2 id="asyncio-semaphore">asyncio.Semaphore<span class="headerlink"> <a href="#asyncio-semaphore" title="permalink">#</a></span></h2>
<p>Screw the docs, too much to read.</p>
<p>We do some googling,
and the first few Stack Overflow answers point us to <a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore">asyncio.Semaphore</a>.</p>
<p>Like its <a href="https://docs.python.org/3/library/threading.html#threading.Semaphore">threading cousin</a>,
we can use it to limit
how many times the body of a <code>with</code> block can be entered in parallel:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="n">sem</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Semaphore</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># ... later</span>
<span class="k">async</span> <span class="k">with</span> <span class="n">sem</span><span class="p">:</span>
    <span class="c1"># this can run no more than 10 times in parallel</span>
</code></pre></div>
<p>Sounds about what we're looking for:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">limit_concurrency</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="n">semaphore</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Semaphore</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">aw</span><span class="p">):</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">semaphore</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">aw</span>

    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">aws</span><span class="p">)):</span>
        <span class="k">yield</span> <span class="n">result</span>
</code></pre></div>
</td></tr></table>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2 .2 .1
<span class="go">0.3: 0.1</span>
<span class="go">0.3: 0.2</span>
<span class="go">0.3: 0.2</span>
<span class="go">0.3: 0.1</span>
<span class="go">0.3: done</span>
</code></pre></div>
<p>... except, because <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather">gather()</a> takes a sequence,
we end up consuming the entire <code>aws</code> iterable right away,
before <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.gather">gather()</a> is even called.
Let's highlight this:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">on_iter_end</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">x</span>
    <span class="n">callback</span><span class="p">()</span>
</code></pre></div>
</td></tr></table>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>    <span class="n">timeout</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">on_iter_end</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;iter end&quot;</span><span class="p">))</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">async_main</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">limit</span><span class="p">),</span> <span class="n">timeout</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>
<p>As expected:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2 .2 .1
<span class="go">iter end</span>
<span class="go">0.3: 0.1</span>
<span class="go">0.3: 0.2</span>
<span class="go">0.3: 0.2</span>
<span class="go">0.3: 0.1</span>
<span class="go">0.3: done</span>
</code></pre></div>
<p>This may be OK for small iterables, but it has two issues:</p>
<ul>
<li>for big iterables, we create thousands upon thousands of tasks,
without actually running them (yet);
that has to cause some memory issues</li>
<li>if the iterable is lazy (say, a paginated API),
we have to wait for all of it to be consumed,
instead of starting to do work as soon as we can</li>
</ul>
<h2 id="asyncio-as-completed">asyncio.as_completed()<span class="headerlink"> <a href="#asyncio-as-completed" title="permalink">#</a></span></h2>
<p>At a quick glance, <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed">asyncio.as_completed()</a> might do what we need
– it takes an iterable of awaitables, runs them concurrently,
and returns an iterator of coroutines that
&quot;can be awaited to get the earliest next result
from the iterable of the remaining awaitables&quot;.</p>
<p>But, it has two issues.</p>
<p>First, <a href="https://github.com/python/cpython/blob/3.11/Lib/asyncio/tasks.py#L557">it consumes the iterable right away</a>:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">as_completed</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># set-up</span>
    <span class="n">todo</span> <span class="o">=</span> <span class="p">{</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">fs</span><span class="p">)}</span>
    <span class="o">...</span>  <span class="c1"># actual logic</span>
</code></pre></div>
<p>The second is more subtle, but just as fundamental.</p>
<p><a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed">as_completed()</a> has no limits of its own
– it's up to us to limit how fast we feed it awaitables.
Presumably, we could wrap the input iterable
into a generator that yields awaitables
only if enough results came out the other end,
and otherwise waits in some way.</p>
<p>However, due to historical reasons,
<a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed">as_completed()</a> takes a plain-old-<em>sync</em>-iterator
– we cannot <code>await</code> anything in its (sync) <a href="https://docs.python.org/3/library/stdtypes.html#iterator.__next__">__next__()</a> method,
and sync waiting of any kind would block (and possibly deadlock)
the entire event loop.</p>
<p>So, no <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed">as_completed()</a> for you.</p>
<!--

.. literalinclude:: mo_30_as_completed.py
    :lines: 13-21

```console
$ python map_unordered.py 2 .1 .2 .2 .1
iter end
0.3: 0.1
0.3: 0.2
0.3: 0.2
0.3: 0.1
0.3: done
```

-->
<h2 id="asyncio-queue">asyncio.Queue<span class="headerlink"> <a href="#asyncio-queue" title="permalink">#</a></span></h2>
<p>Speaking of threading cousins,
how would you implement the (sync) <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered">imap_unordered()</a>
if there was no Pool? Queues, of course!</p>
<p>And <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a> has its own <a href="https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue">Queue</a>,
which you use in pretty much the same way:
start <code>limit</code> worker tasks that loop forever,
pulling awaitables, awaiting them,
and putting the results into a queue.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">limit_concurrency</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="n">aws</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">ndone</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">worker</span><span class="p">():</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">aw</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="k">break</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="kc">True</span><span class="p">,</span> <span class="k">await</span> <span class="n">aw</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="kc">False</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
                <span class="k">break</span>

    <span class="n">worker_tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">worker</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">limit</span><span class="p">)]</span>

    <span class="k">while</span> <span class="n">ndone</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="n">ok</span><span class="p">,</span> <span class="n">rv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">rv</span>
        <span class="k">elif</span> <span class="n">rv</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">rv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ndone</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>
</td></tr></table>
<p>The iterable is exhausted before the last &quot;batch&quot; starts:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2 .3 .3 .2 .1
<span class="go">0.1: 0.1</span>
<span class="go">0.2: 0.2</span>
<span class="go">0.4: 0.3</span>
<span class="go">0.5: 0.3</span>
<span class="go">iter end</span>
<span class="go">0.6: 0.1</span>
<span class="go">0.6: 0.2</span>
<span class="go">0.6: done</span>
</code></pre></div>
<p>I was going to work up to this in a few steps,
but I'll just point out three common bugs
this type of code might have (and these apply to threads too).</p>
<details>
<summary>
First,
we could increment <code>ndone</code> from the worker
but this makes <code>await queue.get()</code> hang forever for empty iterables,
since workers never get to run by the time we get to it;
because there's no other await, it's not even a race condition.
</summary>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">limit_concurrency</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="n">aws</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">ndone</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">worker</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">ndone</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">aw</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">ndone</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">break</span>

            <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="k">await</span> <span class="n">aw</span><span class="p">)</span>

    <span class="n">worker_tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">worker</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">limit</span><span class="p">)]</span>

    <span class="k">while</span> <span class="n">ndone</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="k">yield</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</code></pre></div>
</td></tr></table>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span>
<span class="go">iter end</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">  ...</span>
<span class="go">asyncio.exceptions.TimeoutError</span>
</code></pre></div>
</details>
<p>The solution is to signal the worker is done in-band,
by putting a <a href="/sentinels#what-s-a-sentinel-and-why-do-i-need-one">sentinel</a> on the queue.
I guess a good rule of thumb for this kind of thing
is that for each get() without a timeout, you want to have a put().<sup class="footnote-ref" id="fnref-1"><a href="#fn-1">1</a></sup></p>
<!--
```console
$ python map_unordered.py 2
iter end
0.0: done
```
-->
<details>
<summary>
Second,
you have to catch exceptions raised by awaitables
and send them through the queue as well;
otherwise,
the worker gets killed,
and even though the remaining ones keep going,
that's one more get() waiting for a put() that will never come.
</summary>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">limit_concurrency</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="n">aws</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">ndone</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">done</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">worker</span><span class="p">():</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">aw</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="k">await</span> <span class="n">aw</span><span class="p">)</span>

    <span class="n">worker_tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">worker</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">limit</span><span class="p">)]</span>

    <span class="k">while</span> <span class="n">ndone</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">queue</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">rv</span> <span class="ow">is</span> <span class="n">done</span><span class="p">:</span>
            <span class="n">ndone</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">yield</span> <span class="n">rv</span>
</code></pre></div>
</td></tr></table>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2 <span class="m">0</span> .2 .1
<span class="go">0.1: 0.1</span>
<span class="go">0.2: 0.2</span>
<span class="go">0.4: 0.2</span>
<span class="go">iter end</span>
<span class="go">0.5: 0.1</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">  ...</span>
<span class="go">asyncio.exceptions.TimeoutError</span>
<span class="go">Task exception was never retrieved</span>
<span class="go">future: &lt;Task finished name=&#39;Task-3&#39; coro=&lt;limit_concurrency.&lt;locals&gt;.worker() done, defined at map_unordered.py:20&gt; exception=ZeroDivisionError(&#39;float division by zero&#39;)&gt;</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">  ...</span>
<span class="go">ZeroDivisionError: float division by zero</span>
</code></pre></div>
</details>
<!--
```console
$ python map_unordered.py 2 .1 .2 0 .2 .1
0.1: 0.1
Traceback (most recent call last):
  ...
ZeroDivisionError: float division by zero
```
-->
<p>Finally, our input iterator is synchronous (for now),
so no other task can run while we do <code>next(aws)</code>.
But if it were asynchronous,
any number of tasks could <code>await anext(aws)</code> at any given time,
leading to potential <a href="https://stackoverflow.com/a/46858792">concurrency issues</a>.
The fix is the same as with threads:
either protect that call with a <a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Lock">Lock</a>,
or feed awaitables to workers through an input queue.</p>
<p>Anyway, no need to worry about any that – a better solution awaits.</p>
<h2 id="aside-backpressure">Aside: backpressure<span class="headerlink"> <a href="#aside-backpressure" title="permalink">#</a></span></h2>
<p>At this point, we're technically done
– the queue solution does everything <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered">Pool.imap_unordered()</a> does.</p>
<p>So much so, that, <a href="https://bugs.python.org/issue40110">like imap_unordered()</a>,
it lacks <a href="https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7">backpressure</a>:
when the code retrieving results from the map iterable
can't keep up with the tasks producing results,
the workers keep going regardless,
and the results accumulate in the internal queue,
with potentially infinite memory usage.</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">dummy</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;got result&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">got result</span>
<span class="go">got result</span>
<span class="go">got result</span>
<span class="go">got result</span>
</code></pre></div>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">def</span> <span class="nf">async_print</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;in async_print&#39;</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">arg</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">map_unordered</span><span class="p">(</span><span class="n">async_print</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;got result&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">got result</span>
<span class="go">got result</span>
<span class="go">got result</span>
<span class="go">got result</span>
</code></pre></div>
<p>This can be fixed by making the queue bounded,
so that when the queue gets full,
workers can't put() new data until
the consumer get()s some old data.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">15</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>    <span class="n">queue</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
</code></pre></div>
</td></tr></table><div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">map_unordered</span><span class="p">(</span><span class="n">async_print</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;got result&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">got result</span>
<span class="go">3</span>
<span class="go">got result</span>
<span class="go">4</span>
<span class="go">got result</span>
<span class="go">got result</span>
<span class="go">got result</span>
</code></pre></div>
<p>Alas, we don't have access to the queue <a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered">imap_unordered()</a> uses,
but that's a story for another time.</p>
<!--

# asyncio.Queue, redux

.. literalinclude:: mo_45_queue_as_completed.py
    :lines: 13-35

```console
$ python map_unordered.py 2 .1 .2 .2 .1
iter end
0.1: 0.1
0.2: 0.2
0.2: 0.2
0.2: 0.1
0.2: done
```

( ≖_≖)

Everything runs at once...


as_completed() yields the coroutines before they are actually finished:

> Each coroutine returned can be awaited to get the earliest next result from the iterable of the remaining awaitables.

That is, the waiting happens when you `await` them.

This is unlike the original, not-async as_completed() from concurrent.futures:

https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.as_completed

.. literalinclude:: sync_as_completed.py
    :lines: 1-

```console
$ python sync_as_completed.py
0.1
0.2
0.3
0.3
```

Note there's no `future.result()` call here; unlike the async version, the wait happens *inside* the as_completed() iterator.


---

If only there was some other way to wait tasks, also inspired by the concurrent.futures API, that actually blocks until they're done.

https://docs.python.org/3/library/asyncio-task.html#asyncio.wait

.. literalinclude:: mo_46_queue_wait.py
    :lines: 26-27

```console
$ python map_unordered.py 2 .1 .2 .2 .1
0.1: 0.1
0.2: 0.2
iter end
0.3: 0.1
0.3: 0.2
0.3: done
```

-->
<h2 id="asyncio-wait">asyncio.wait()<span class="headerlink"> <a href="#asyncio-wait" title="permalink">#</a></span></h2>
<p>This whole let's-pretend-we're-using-threads thing works,
but maybe it's not all that idiomatic.
If only there was some sort of low level <a href="https://linux.die.net/man/2/select">select()</a>-like primitive
that takes a set of tasks
and blocks until at least one of them finishes.</p>
<p>And of course there is – we've been purposefully avoiding it this entire time –
it's <a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.wait">asyncio.wait()</a>, and it can do exactly that.</p>
<p>By default, it waits until all tasks are completed,
which for our purposes isn't much better than <a href="#asyncio-gather">gather()</a>.
But, with <code>return_when=​FIRST_COMPLETED</code>,
it waits until <em>at least one</em> task is completed.</p>
<p>We can use this to keep a <code>limit</code>-sized set of tasks
updated with new tasks as soon as the old ones finish:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">limit_concurrency</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="n">aws</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
    <span class="n">aws_ended</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">pending</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">pending</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">aws_ended</span><span class="p">:</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">pending</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">limit</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">aws_ended</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">aw</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">aws_ended</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pending</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">aw</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">pending</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">done</span><span class="p">,</span> <span class="n">pending</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span>
            <span class="n">pending</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">FIRST_COMPLETED</span>
        <span class="p">)</span>
        <span class="k">while</span> <span class="n">done</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">done</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div>
</td></tr></table>
<p>We take this opportunity to change the contract
between <code>limit_concurrency()</code> and <code>map_unordered()</code>:
instead of results, <code>limit_concurrency()</code> now yields awaitables,
making it more consistent –
awaitables in, awaitables out.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">map_unordered</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="n">aws</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">)</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">limit_concurrency</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
        <span class="k">yield</span> <span class="k">await</span> <span class="n">task</span>
</code></pre></div>
</td></tr></table>
<p><code>map_unordered()</code> becomes an async generator, instead of just returning one;
we should have probably done this done this from the beginning,
to make it clear it's not sync.</p>
<p>And it has all the properties that the Queues one has:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2 .2 .1
<span class="go">0.1: 0.1</span>
<span class="go">0.2: 0.2</span>
<span class="go">0.3: 0.1</span>
<span class="go">0.3: 0.2</span>
<span class="go">iter end</span>
<span class="go">0.3: done</span>
</code></pre></div>
<p>... and backpressure too:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">map_unordered</span><span class="p">(</span><span class="n">async_print</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;got result&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0</span>
<span class="go">got result</span>
<span class="go">1</span>
<span class="go">got result</span>
<span class="go">2</span>
<span class="go">got result</span>
<span class="go">3</span>
<span class="go">got result</span>
</code></pre></div>
<h2 id="async-iterators">Async iterators<span class="headerlink"> <a href="#async-iterators" title="permalink">#</a></span></h2>
<p>https://docs.python.org/3/glossary.html#term-asynchronous-iterable</p>
<p>TODO: punch our way through all of the exceptions</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>

<span class="k">async</span> <span class="k">def</span> <span class="nf">as_async_iter</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
</code></pre></div>
</td></tr></table>
<p>In main():</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">64</span>
<span class="normal">65</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span>
</code></pre></div>
</td></tr></table>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2 .2 .1
<span class="go">Traceback (most recent call last):</span>
<span class="go">  ...</span>
<span class="go">  File &quot;map_unordered.py&quot;, line 9, in map_unordered</span>
<span class="go">    aws = map(func, iterable)</span>
<span class="go">TypeError: &#39;async_generator&#39; object is not iterable</span>
</code></pre></div>
<hr />
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">_map_async</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div>
</td></tr></table>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">map_unordered</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="n">is_async</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">AsyncIterator</span><span class="p">)</span>
    <span class="n">map_func</span> <span class="o">=</span> <span class="n">_map_async</span> <span class="k">if</span> <span class="n">is_async</span> <span class="k">else</span> <span class="nb">map</span>
    <span class="n">aws</span> <span class="o">=</span> <span class="n">map_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">limit_concurrency</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
        <span class="k">yield</span> <span class="k">await</span> <span class="n">task</span>
</code></pre></div>
</td></tr></table>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2 .2 .1
<span class="go">Traceback (most recent call last):</span>
<span class="go">  ...</span>
<span class="go">  File &quot;map_unordered.py&quot;, line 23, in limit_concurrency</span>
<span class="go">    aws = iter(aws)</span>
<span class="go">TypeError: &#39;async_generator&#39; object is not iterable</span>
</code></pre></div>
<hr />
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">limit_concurrency</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="n">is_async</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aws</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">AsyncIterator</span><span class="p">)</span>

    <span class="n">aws</span> <span class="o">=</span> <span class="n">aiter</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_async</span> <span class="k">else</span> <span class="nb">iter</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
</code></pre></div>
</td></tr></table>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2 .2 .1
<span class="go">Traceback (most recent call last):</span>
<span class="go">  ...</span>
<span class="go">  File &quot;map_unordered.py&quot;, line 32, in limit_concurrency</span>
<span class="go">    aw = next(aws)</span>
<span class="go">TypeError: &#39;async_generator&#39; object is not an iterator</span>
</code></pre></div>
<hr />
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>            <span class="k">try</span><span class="p">:</span>
                <span class="n">aw</span> <span class="o">=</span> <span class="k">await</span> <span class="n">anext</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_async</span> <span class="k">else</span> <span class="nb">next</span><span class="p">(</span><span class="n">aws</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopAsyncIteration</span> <span class="k">if</span> <span class="n">is_async</span> <span class="k">else</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">aws_ended</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pending</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">aw</span><span class="p">))</span>
</code></pre></div>
</td></tr></table>
<p>It may not look pretty, but it gets the job done.</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2 .2 .1
<span class="go">0.1: 0.1</span>
<span class="go">0.2: 0.2</span>
<span class="go">0.3: 0.1</span>
<span class="go">0.3: 0.2</span>
<span class="go">iter end</span>
<span class="go">0.3: done</span>
</code></pre></div>
<h2 id="exceptions">Exceptions<span class="headerlink"> <a href="#exceptions" title="permalink">#</a></span></h2>
<p>OK, so what about exceptions?</p>
<p>Sometimes, you still want to process the rest of the things even if one failed.</p>
<hr />
<p>A cheap way is to have the user handle this by wrapping their function:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">return_exceptions</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">e</span>

    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">map_unordered</span><span class="p">(</span><span class="n">return_exceptions</span><span class="p">(</span><span class="n">sleep</span><span class="p">),</span> <span class="p">[</span><span class="mf">.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">.1</span><span class="p">],</span> <span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">division by zero</span>
<span class="go">0.1</span>
<span class="go">0.2</span>
</code></pre></div>
<hr />
<p>Alternatively, we could just bubble up the Task to the user;
then they're free to do whatever (either await it, or check the exception).</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">map_unordered</span><span class="p">(</span><span class="n">sleep</span><span class="p">,</span> <span class="p">[</span><span class="mf">.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">.1</span><span class="p">],</span> <span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="k">await</span> <span class="n">task</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">async</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">map_unordered</span><span class="p">(</span><span class="n">sleep</span><span class="p">,</span> <span class="p">[</span><span class="mf">.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">.1</span><span class="p">],</span> <span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span> <span class="ow">or</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">division by zero</span>
<span class="go">0.1</span>
<span class="go">0.2</span>
</code></pre></div>
<p>This works, but it somehow feels too low level (and, unlike map).</p>
<p>Also, the tasks are guaranteed to be done at this point,
so aside from telling results apart from exceptions,
they're not all that useful.</p>
<hr />
<p>It's probably safe to take some inspiration in terms of ergonomics
from gather(), and its <code>return_exceptions</code> option:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">aws</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">sleep</span><span class="p">,</span> <span class="p">[</span><span class="mf">.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">.1</span><span class="p">])</span>
<span class="gp">... </span><span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">aws</span><span class="p">,</span> <span class="n">return_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0.2</span>
<span class="go">division by zero</span>
<span class="go">0.1</span>
</code></pre></div>
<p>But, <code>return_exceptions</code> is not enough;
the results yielded by map_unordered() won't be in args order,
so how do you know which one failed?</p>
<hr />
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">_return_exceptions</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">func</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</code></pre></div>
</td></tr></table>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">24</span>
<span class="normal">25</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">_return_args</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">arg</span><span class="p">,</span> <span class="k">await</span> <span class="n">func</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
</code></pre></div>
</td></tr></table>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">async</span> <span class="k">def</span> <span class="nf">map_unordered</span><span class="p">(</span>
    <span class="n">func</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_exceptions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_args</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="n">return_exceptions</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_return_exceptions</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_args</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_return_args</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>

    <span class="n">is_async</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">AsyncIterator</span><span class="p">)</span>
</code></pre></div>
</td></tr></table>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code><span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span></code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>    <span class="k">async</span> <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">map_unordered</span><span class="p">(</span>
        <span class="n">sleep</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">return_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_args</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</td></tr></table>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python map_unordered.py <span class="m">2</span> .1 .2 <span class="m">0</span> .2 .1
<span class="go">0.1: 0.1 -&gt; 0.1</span>
<span class="go">0.1: 0.0 -&gt; float division by zero</span>
<span class="go">0.2: 0.2 -&gt; 0.2</span>
<span class="go">0.3: 0.2 -&gt; 0.2</span>
<span class="go">0.3: 0.1 -&gt; 0.1</span>
<span class="go">iter end</span>
<span class="go">0.3: done</span>
</code></pre></div>
<section class="footnotes">
<ol>
<li id="fn-1"><p>Does this have a fancy, academic name? <a href="/about#contact">Do let me know!</a> <a href="#fnref-1" class="footnote"><sup>[return]</sup></a></p></li>
</ol>
</section>








</div>
</main>


<footer class="footer">
<p class="text-gray">
<a href="/">home</a>
∙ <a href="/_feed/index.xml">feed</a>
∙ <a href="/about">about</a>

∙ © 2021 lemon24



</footer>


</div>