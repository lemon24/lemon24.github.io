<!doctype html>

<meta name="viewport" content="width=device-width" />


<link rel="stylesheet" href="/_static/spectre.css">
<link rel="stylesheet" href="/_static/pygments.css">
<link rel="stylesheet" href="/_static/style.css">

<link rel="alternate" type="application/atom+xml" title="Atom feed" href="/_feed/index.xml" />




<title>conway-cubes-perf - death and gravity</title>


<script>
/* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
function set_vh() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}
/* we do it once, now, *and* on every resize */
set_vh();
window.addEventListener('resize', set_vh);
</script>


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4RY2QR580X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', "G-4RY2QR580X");
</script>



<div class="main container grid-lg">


<header>
<nav>
<ul class="breadcrumb">

<li class="breadcrumb-item">
    <a href="/">death and gravity</a>
</li>

</ul>
</nav>

<h1>conway-cubes-perf</h1>

<p class="text-gray"><small>


</small></p>

</header>


<main class="content columns">
<div class="column col-sm-12 col-md-10 col-8">

<p>... in which we optimize <a href="/conway-cubes">our Advent of Code 2020 day 17 solution</a>,
a multidimensional implementation of <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a>,
using nothing but pure Python and the stdlib <a href="https://docs.python.org/3/library/profile.html">profile</a> module.</p>
<p>TODO: mention optimizations aren't to the algorithm, but the Python code</p>
<p>We'll start from the last version of the solution;
you can download it <a href="/_file/conway-cubes-perf/conway-cubes-4d.py">here</a>.</p>
<details>
<summary>Contents</summary>
<section class="toc">
<ul>
<li><a href="#why-is-it-slow">Why is it slow?</a></li>
<li><a href="#prep-work">Prep work</a></li>
<li><a href="#intro-to-profiling">Intro to profiling</a></li>
<li><a href="#offenders">Offenders</a></li>
<li><a href="#make-directions">make_directions()</a></li>
<li><a href="#any-coord-0">any(coord < 0 ...)</a></li>
<li><a href="#intermision-more-tests">Intermision: more tests</a></li>
<li><a href="#neighbor-coords">neighbor_coords</a></li>
<li><a href="#going-multidimensional-again">Going multidimensional, again</a></li>
<li><a href="#the-real-world">The real world</a></li>
<li><a href="#bonus-pypy">Bonus: PyPy</a></li>
<li><a href="#conclusions">Conclusions</a></li>
<li><a href="#bonus-other-things-i-tried">Bonus: other things I tried</a></li>
</ul>
</section>
</details>
<h2 id="why-is-it-slow">Why is it slow?<span class="headerlink"> <a href="#why-is-it-slow" title="permalink">#</a></span></h2>
<p>Our solution is pretty naive:
for every cell in a multidimensional array of cells,
it counts how many of the cell's neighbors are active,
and changes the cell state according based on that.</p>
<p>As we add more dimensions, the run time increases by orders or magnitude:
for a world of size 16, I get .02 seconds for 2D,
1 second fo 3D, and 1 minute for 4D.
Likewise, the run time is not increasing linearly with the world size either:
for 4D, a world of size 20 is not taking only 1.25 times longer,
but ~2.4 times!</p>
<p>To get a better picture of why this is happening,
let's count the number of cells and and neighbors we need to look at every cycle
(as a reminder, neighbors are all the cells in a size 3 &quot;square&quot; centered on the cell, except the cell itself):</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">size</span> <span class="o">=</span> <span class="mi">16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dims</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">size</span> <span class="o">**</span> <span class="n">dims</span><span class="p">,</span> <span class="n">size</span> <span class="o">**</span> <span class="n">dims</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">**</span> <span class="n">dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(256, 2048)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dims</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">size</span> <span class="o">**</span> <span class="n">dims</span><span class="p">,</span> <span class="n">size</span> <span class="o">**</span> <span class="n">dims</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">**</span> <span class="n">dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(4096, 106496)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dims</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">size</span> <span class="o">**</span> <span class="n">dims</span><span class="p">,</span> <span class="n">size</span> <span class="o">**</span> <span class="n">dims</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">**</span> <span class="n">dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(65536, 5242880)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">size</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">size</span> <span class="o">**</span> <span class="n">dims</span><span class="p">,</span> <span class="n">size</span> <span class="o">**</span> <span class="n">dims</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">**</span> <span class="n">dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(160000, 12800000)</span>
</code></pre></div>
<p>That is indeed <a href="https://en.wikipedia.org/wiki/Exponential_growth">exponential growth</a> (the number of dimensions is the exponent).</p>
<p>As mentioned previously, there are <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life#Algorithms">many optimizations</a> to simulating Life.
They involve reducing the number of cells to look at
(e.g. a cell that didn't change last cycle, and whose neighbors didn't change,
won't change this cycle either), making neighbors faster to count,
or detecting parts of the board that repeat either in space or time.</p>
<p>Instead of using a different algorithm, or a different, faster language,
let's ignore all of that and try to make our existing Python code faster,
since that's something both easier to do, and easier to translate to
problems that don't have extensive Wikipedia pages on them.</p>
<h2 id="prep-work">Prep work<span class="headerlink"> <a href="#prep-work" title="permalink">#</a></span></h2>
<p>The last version of the script goes through all of the tests
and prints the results for the two parts of the problem (3 and 4 dimensions).</p>
<p>Let's make it a bit easier to run a single simulation
with a specific world size, dimension, and number of cycles.</p>
<p>First, we'll move the formatting test (line 22)
and the other tests at the end of the file
into functions:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">TEST_INPUT</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">.#.</span>
<span class="s2">..#</span>
<span class="s2">###</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">test_parse_roundtrip</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">format_2d</span><span class="p">(</span><span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">))</span> <span class="o">==</span> <span class="n">TEST_INPUT</span>

<span class="k">def</span> <span class="nf">test_2</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span>

    <span class="n">world</span><span class="p">,</span> <span class="n">active_cubes</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">),</span> <span class="n">format_world</span><span class="o">=</span><span class="n">format_2d</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">active_cubes</span> <span class="o">==</span> <span class="mi">5</span>
    <span class="k">assert</span> <span class="n">world</span> <span class="o">==</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">    ........</span>
<span class="s2">    ........</span>
<span class="s2">    ........</span>
<span class="s2">    ........</span>
<span class="s2">    .....#..</span>
<span class="s2">    ...#.#..</span>
<span class="s2">    ....##..</span>
<span class="s2">    ........</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">test_3</span><span class="p">():</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">active_cubes</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">active_cubes</span> <span class="o">==</span> <span class="mi">112</span>

<span class="k">def</span> <span class="nf">test_4</span><span class="p">():</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">active_cubes</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">active_cubes</span> <span class="o">==</span> <span class="mi">848</span>
</code></pre></div>
</td></tr></table><p>We want to be able to run fewer cycles, so we add a new argument to <code>run</code>:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>120</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">format_world</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cycles</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>125</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>    <span class="k">for</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">world</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">cycles</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">worlds</span><span class="p">):</span>
</code></pre></div>
</td></tr></table><p>And then remove the rest of the top level code
in favor of a rudimentary CLI:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">INPUT</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">.##...#.</span>
<span class="s2">.#.###..</span>
<span class="s2">..##.#.#</span>
<span class="s2">##...#.#</span>
<span class="s2">#..#...#</span>
<span class="s2">#..###..</span>
<span class="s2">.##.####</span>
<span class="s2">..#####.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;test&#39;</span><span class="p">:</span> <span class="n">TEST_INPUT</span><span class="p">,</span> <span class="s1">&#39;real&#39;</span><span class="p">:</span> <span class="n">INPUT</span><span class="p">}[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">size</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">cycles</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">run</span><span class="p">(</span>
        <span class="n">size</span><span class="p">,</span>
        <span class="n">dimensions</span><span class="p">,</span>
        <span class="n">parse_input</span><span class="p">(</span><span class="nb">input</span><span class="p">),</span>
        <span class="n">format_world</span><span class="o">=</span><span class="n">format_2d</span> <span class="k">if</span> <span class="n">dimensions</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cycles</span><span class="o">=</span><span class="n">cycles</span><span class="p">,</span>
    <span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="n">main</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</code></pre></div>
</td></tr></table><p>We'll run the tests using <a href="https://docs.pytest.org/en/stable/">pytest</a>.
The 4D one takes a while, so we skip it with <code>-k</code>:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$</span> pytest conway-cubes.py -q -k <span class="s1">&#39;not 4&#39;</span>
<span class="go">..                                                                       [100%]</span>
<span class="go">3 passed, 1 deselected in 1.14s</span>
</code></pre></div>
<p>The script is run like this:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$</span> python conway-cubes.py real <span class="m">20</span> <span class="m">4</span> <span class="m">6</span>
<span class="go">after cycle #0 (0.01s): ...</span>
<span class="go">after cycle #1 (24.15s): ...</span>
<span class="go">after cycle #2 (23.45s): ...</span>
<span class="go">after cycle #3 (23.79s): ...</span>
<span class="go">after cycle #4 (24.31s): ...</span>
<span class="go">after cycle #5 (24.15s): ...</span>
<span class="go">after cycle #6 (24.07s): ...</span>
<span class="go">the result is 2276 (143.94s)</span>
</code></pre></div>
<h2 id="intro-to-profiling">Intro to profiling<span class="headerlink"> <a href="#intro-to-profiling" title="permalink">#</a></span></h2>
<p>The Python standard library provides a <a href="https://docs.python.org/3/library/profile.html">profiler</a>
which allow getting statistics for how often and how long
various functions get executed.</p>
<p>For us, the easiest way to use it is to pass a whole script, like this:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash"><span></span><code>python -m cProfile <span class="o">[</span>scriptfile<span class="o">]</span> <span class="o">[</span>arg<span class="o">]</span> ...
</code></pre></div>
<section class="admonition note">
<div class="admonition-text">
<p>You can also use it to profile specific bits of code;
 see <a href="https://docs.python.org/3/library/profile.html#profile.Profile">this</a>
 for details on that.</p>
</div>
</section>
<p>Before profiling, let's run the script as is, to get a baseline run time;
I've picked a small enough world size to get almost instant feedback:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$</span> python conway-cubes.py <span class="nb">test</span> <span class="m">8</span> <span class="m">4</span> <span class="m">1</span>
<span class="go">after cycle #0 (0.00s): ...</span>
<span class="go">after cycle #1 (0.65s): ...</span>
<span class="go">the result is 29 (0.65s)</span>
</code></pre></div>
<p>After the profiler finishes running the script,
it prints a table with the number of calls and run time for each function.
By default, they're sorted by function name, which isn't very useful;
instead, we'll use the <code>-s</code> option to sort by
&quot;the cumulative time spent in this and all subfunctions&quot;.</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$</span> python -m cProfile -s cumulative conway-cubes.py <span class="nb">test</span> <span class="m">8</span> <span class="m">4</span> <span class="m">1</span>
<span class="go">after cycle #0 (0.00s): ...</span>
<span class="go">after cycle #1 (1.04s): ...</span>
<span class="go">the result is 29 (1.04s)</span>

<span class="go">         2268873 function calls (2241817 primitive calls) in 1.044 seconds</span>

<span class="go">   Ordered by: cumulative time</span>

<span class="go">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span>
<span class="go">        1    0.000    0.000    1.044    1.044 {built-in method builtins.exec}</span>
<span class="go">        1    0.000    0.000    1.044    1.044 conway-cubes.py:1(&lt;module&gt;)</span>
<span class="go">        1    0.000    0.000    1.044    1.044 conway-cubes.py:120(run)</span>
<span class="go">        3    0.000    0.000    1.037    0.346 conway-cubes.py:104(simulate_forever)</span>
<span class="go">        1    0.005    0.005    1.036    1.036 conway-cubes.py:74(simulate)</span>
<span class="go">     4096    0.396    0.000    1.024    0.000 conway-cubes.py:28(get_active_neighbors)</span>
<span class="go">   327680    0.224    0.000    0.408    0.000 {built-in method builtins.any}</span>
<span class="go">  1557736    0.192    0.000    0.192    0.000 conway-cubes.py:37(&lt;genexpr&gt;)</span>
<span class="go">   327680    0.147    0.000    0.147    0.000 conway-cubes.py:32(&lt;listcomp&gt;)</span>
<span class="go">     4096    0.005    0.000    0.064    0.000 conway-cubes.py:23(make_directions)</span>
<span class="go">     4096    0.059    0.000    0.059    0.000 conway-cubes.py:25(&lt;listcomp&gt;)</span>
<span class="go">33938/8194    0.012    0.000    0.012    0.000 conway-cubes.py:56(ndenumerate)</span>
<span class="go">        1    0.001    0.001    0.007    0.007 {built-in method builtins.sum}</span>
<span class="go">     4097    0.001    0.000    0.006    0.000 conway-cubes.py:138(&lt;genexpr&gt;)</span>
<span class="go">   1170/2    0.001    0.000    0.001    0.001 conway-cubes.py:89(make_world)</span>
<span class="go">    146/2    0.000    0.000    0.001    0.001 conway-cubes.py:93(&lt;listcomp&gt;)</span>
<span class="go">     4100    0.001    0.000    0.001    0.000 {built-in method builtins.len}</span>
<span class="go">        6    0.000    0.000    0.000    0.000 {built-in method builtins.print}</span>
<span class="go">        1    0.000    0.000    0.000    0.000 conway-cubes.py:96(copy_centered_2d)</span>
<span class="go">        1    0.000    0.000    0.000    0.000 conway-cubes.py:8(parse_input)</span>
<span class="go">       10    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}</span>
<span class="go">        1    0.000    0.000    0.000    0.000 conway-cubes.py:9(&lt;listcomp&gt;)</span>
<span class="go">        5    0.000    0.000    0.000    0.000 {built-in method time.perf_counter}</span>
<span class="go">        3    0.000    0.000    0.000    0.000 conway-cubes.py:10(&lt;listcomp&gt;)</span>
<span class="go">        1    0.000    0.000    0.000    0.000 conway-cubes.py:6(&lt;dictcomp&gt;)</span>
<span class="go">        1    0.000    0.000    0.000    0.000 {method &#39;splitlines&#39; of &#39;str&#39; objects}</span>
<span class="go">        1    0.000    0.000    0.000    0.000 {method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects}</span>
</code></pre></div>
<p>Since the output is quite long,
I'll just show the relevant rows in the middle of the table from now on.</p>
<p>You may notice the run time increased;
that's because profiling adds some overhead.
We are using the <code>cProfile</code> modle, a C implementation of the profiler;
if you try the pure-Python version, <code>profile</code>,
it'll take even more, around 25x on my machine.</p>
<section class="admonition tip">
<div class="admonition-text">
<p>If you're following along, you might find it useful to use <a href="https://eradman.com/entrproject/">entr</a>
 to re-run the command every time you save the file.
 I used something like this:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash"><span></span><code><span class="nb">echo</span> conway-cubes.py <span class="p">|</span> entr -rcs <span class="s2">&quot;</span>
<span class="s2">python -m cProfile -s cumulative conway-cubes.py test 8 4 1 \</span>
<span class="s2">| grep -A20 ncalls</span>
<span class="s2">&quot;</span>
</code></pre></div>
</div>
</section>
<h2 id="offenders">Offenders<span class="headerlink"> <a href="#offenders" title="permalink">#</a></span></h2>
<p>Looking at the data, we see that almost the entire 1 second run time
is spent in <code>get_active_neighbors()</code>,
which is consistent with our initial calculation.</p>
<p>Let's see it in full:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">get_active_neighbors</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
    <span class="n">active_neighbors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">offsets</span> <span class="ow">in</span> <span class="n">make_directions</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>

        <span class="n">neighbor_coords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">coord</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">offsets</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">coord</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">neighbor_coords</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;active on edge: </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">neighbor</span> <span class="o">=</span> <span class="n">world</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">neighbor_coords</span><span class="p">:</span>
                <span class="n">neighbor</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;active on edge: </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">active_neighbors</span> <span class="o">+=</span> <span class="n">neighbor</span>

    <span class="k">return</span> <span class="n">active_neighbors</span>
</code></pre></div>
</td></tr></table><p>Of this, about .4s are spent in the function itself (<code>tottime</code>),
and the rest in subfunctions
(list comprehension etc. seem to be treated as functions as well):</p>
<ul>
<li>.4s in the <code>any(coord &lt; 0 ...)</code> check, .2s of which in the generator expression</li>
<li>.15s in the <code>neighbor_coords</code> list comprehension at line 32</li>
<li>.06s in <code>make_directions()</code>, almost all of it in the list comprehension at line 25</li>
</ul>
<h2 id="make-directions">make_directions()<span class="headerlink"> <a href="#make-directions" title="permalink">#</a></span></h2>
<p>Let's start small: <code>make_directions()</code> only takes 6% of the total time,
but should be quite easy to speed up –
it is a pure function (the result only depends on the arguments),
and has a single argument with only a handful of values (2, 3, 4).</p>
<p>We could pre-compute the results for each dimension,
save them in a global dict, and reuse them from there.
Thankfully, the <a href="https://docs.python.org/3/library/functools.html">functools.lru_cache</a> decorator from the standard library
allows us to do just that in a transparent way:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>2</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>24
25
26</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="nd">@lru_cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">make_directions</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="c1"># ...</span>
</code></pre></div>
</td></tr></table><p>Now, <code>make_directions()</code> will save the return value
for a specific argument on the first call, and
subsequent calls with the same argument will return the saved value.</p>
<p>Here's the result:</p>
<pre class="code code-container"><code>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     4096    0.390    0.000    0.951    0.000 conway-cubes.py:30(get_active_neighbors)
      ...
        1    0.000    0.000    0.000    0.000 conway-cubes.py:24(make_directions)
</code></pre>
<p>A ~6% improvement for this little work is more than decent.</p>
<h2 id="any-coord-0">any(coord &lt; 0 ...)<span class="headerlink"> <a href="#any-coord-0" title="permalink">#</a></span></h2>
<p>Emboldened by this, we'll see if we can do anything about the
<code>any(coord &lt; 0 ...)</code> check.</p>
<p>There's more than one way to try and fix it,
but before exploring any of them,
let's look a bit harder at <code>get_active_neighbors()</code>:</p>
<ul>
<li>for every neighbor, we're checking if any of its coordinates is &lt; 0;</li>
<li>but by definition, the lowest a neighbor can be is -1 from the cell;</li>
<li>so that's equivalent to checking that the cell coordinate is &lt; 1;</li>
<li>since the cell isn't moving, we can do it just once, outside the neighbor loop.</li>
</ul>
<p>It might not seem like a lot, but remember the number of neighbors
increases exponentially:
in 2D, we're doing the check 8 times;
in 4D, we're doing it 80 times!</p>
<p>So:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>30
31
32
33
34
35
36
37
38</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">get_active_neighbors</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">coord</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;active on edge: </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">active_neighbors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">offsets</span> <span class="ow">in</span> <span class="n">make_directions</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
        <span class="n">neighbor_coords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1"># ...</span>
</code></pre></div>
</td></tr></table><p>Which gives us a 57% improvement!</p>
<pre class="code code-container"><code>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     4096    0.265    0.000    0.407    0.000 conway-cubes.py:30(get_active_neighbors)
   327680    0.136    0.000    0.136    0.000 conway-cubes.py:37(&lt;listcomp&gt;)
33938/8194    0.010    0.000    0.010    0.000 conway-cubes.py:56(ndenumerate)
        1    0.001    0.001    0.006    0.006 {built-in method builtins.sum}
     4097    0.001    0.000    0.006    0.000 conway-cubes.py:138(&lt;genexpr&gt;)
     4096    0.003    0.000    0.005    0.000 {built-in method builtins.any}
    17656    0.003    0.000    0.003    0.000 conway-cubes.py:31(&lt;genexpr&gt;)
</code></pre>
<h2 id="intermision-more-tests">Intermision: more tests<span class="headerlink"> <a href="#intermision-more-tests" title="permalink">#</a></span></h2>
<p>There's a slight issue, though:
in the original version, if the check failed, we'd skip that neighbor
(assume it's not active); now we're not doing that anymore.</p>
<p>This means that for a cell on the top/left/... edge of the world (index 0),
we will be getting the state for its neighbors at the far end (index -1).</p>
<p>As long as the neighbors on the far end are inactive, it will still work;
thankfully, we are checking that as well –
that's what the <code>try ... except IndexError</code> does.</p>
<p>But now we've made a bit of logic dependent on another that's quite far from it.
Instead of just reasoning through it, let's verify with some additional tests.</p>
<p>We're using some helpers from the <code>pytest</code> module,
so we'll add the tests to a new file, say, <code>test_conway_cubes.py</code>:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>1
2
3
4
5
6
7
8
9</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span>

<span class="kn">import</span> <span class="nn">pytest</span>

<span class="c1"># hack to &quot;import&quot; the contents of a module that&#39;s not a valid identifier;</span>
<span class="c1"># exec(&lt;source string&gt;) will execute a string of code in the current namespace;</span>
<span class="c1"># this means the original tests will also be available in this module</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="n">exec</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirpath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;conway-cubes.py&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</code></pre></div>
</td></tr></table><p>The first test checks we get errors when there are active cells on the edges:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        #..</span>
<span class="sd">        ...</span>
<span class="sd">        ...</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
        <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        .#.</span>
<span class="sd">        ...</span>
<span class="sd">        ...</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
        <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        ...</span>
<span class="sd">        ..#</span>
<span class="sd">        ...</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
        <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        ...</span>
<span class="sd">        ...</span>
<span class="sd">        .#.</span>
<span class="sd">        &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">]</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_edge_errors</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
        <span class="n">run</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">dedent</span><span class="p">(</span><span class="nb">input</span><span class="p">)),</span> <span class="n">cycles</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>
</td></tr></table><p>Here, the <a href="https://docs.pytest.org/en/stable/parametrize.html#pytest-mark-parametrize">parametrize</a> decorator defines 4 different <code>input</code> arguments,
so that the <code>test_edge_errors</code> function will run 4 times using them in turn.</p>
<p>The second test checks that the new world can have active cells on the edges,
as long as the old one didn't:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="s1">&#39;input, expected_output&#39;</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">            .....</span>
<span class="sd">            .#...</span>
<span class="sd">            .#...</span>
<span class="sd">            .#...</span>
<span class="sd">            .....</span>
<span class="sd">            &quot;&quot;&quot;</span><span class="p">,</span>
            <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">            .....</span>
<span class="sd">            .....</span>
<span class="sd">            ###..</span>
<span class="sd">            .....</span>
<span class="sd">            .....</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">            .....</span>
<span class="sd">            .....</span>
<span class="sd">            .....</span>
<span class="sd">            .###.</span>
<span class="sd">            .....</span>
<span class="sd">            &quot;&quot;&quot;</span><span class="p">,</span>
            <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">            .....</span>
<span class="sd">            .....</span>
<span class="sd">            ..#..</span>
<span class="sd">            ..#..</span>
<span class="sd">            ..#..</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">),</span>

    <span class="p">]</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_edge_ok</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">expected_output</span><span class="p">):</span>
    <span class="n">world</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">dedent</span><span class="p">(</span><span class="nb">input</span><span class="p">)),</span> <span class="n">cycles</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">format_2d</span><span class="p">(</span><span class="n">world</span><span class="p">)</span> <span class="o">==</span> <span class="n">dedent</span><span class="p">(</span><span class="n">expected_output</span><span class="p">)</span>
</code></pre></div>
</td></tr></table><p>Because of parametrization, we get 6 actual tests:
4 for <code>test_edge_errors</code>, and 2 for <code>test_edge_ok</code>:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$</span> pytest test_conway_cubes.py -q -k edge
<span class="go">......                                                                   [100%]</span>
<span class="go">6 passed, 4 deselected in 0.02s</span>
</code></pre></div>
<h2 id="neighbor-coords">neighbor_coords<span class="headerlink"> <a href="#neighbor-coords" title="permalink">#</a></span></h2>
<p>Next up is the <code>neighbor_coords</code> list comprehension.</p>
<p>Using functions written in C may remove some of the comprehension overhead;
let's if it works:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>36
37</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>    <span class="k">for</span> <span class="n">offsets</span> <span class="ow">in</span> <span class="n">make_directions</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
        <span class="n">neighbor_coords</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">offsets</span><span class="p">))</span>
</code></pre></div>
</td></tr></table><p>It's not much better:</p>
<pre class="code code-container"><code>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     4096    0.391    0.000    0.397    0.000 conway-cubes.py:30(get_active_neighbors)
33938/8194    0.011    0.000    0.011    0.000 conway-cubes.py:53(ndenumerate)
</code></pre>
<p>What if instead of using sum, which is generic to any iterable,
we used a function that's made specifically for 2 numbers?</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>30
31</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">starmap</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>39
40</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>    <span class="k">for</span> <span class="n">offsets</span> <span class="ow">in</span> <span class="n">make_directions</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
        <span class="n">neighbor_coords</span> <span class="o">=</span> <span class="n">starmap</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">offsets</span><span class="p">))</span>
</code></pre></div>
</td></tr></table><p>This is working slighly better, with a 25% improvement:</p>
<pre class="code code-container"><code>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     4096    0.301    0.000    0.306    0.000 conway-cubes.py:33(get_active_neighbors)
33938/8194    0.011    0.000    0.011    0.000 conway-cubes.py:56(ndenumerate)
</code></pre>
<p>We've now exhausted all the obvious things to improve;
most of the time is spent in <code>get_active_neighbors</code>, not its subfunctions.</p>
<p>You may remember the <code>any()</code> call spent almost as much time
in the function itself (<code>tottime</code>) as in the generator expression;
indeed, calling <em>any</em> function seems to have significant overhead:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$</span> python -m timeit -s <span class="s1">&#39;from operator import add&#39;</span> <span class="s1">&#39;add(1, 2)&#39;</span>
<span class="go">5000000 loops, best of 5: 49.3 nsec per loop</span>
<span class="gp">$</span> python -m timeit <span class="s1">&#39;1 + 2&#39;</span>
<span class="go">50000000 loops, best of 5: 7.98 nsec per loop</span>
</code></pre></div>
<p>Let's try something different.</p>
<p>In the top level loop, we're calling 3 functions to add 4 pairs of numbers.
What if we didn't?
Having more general code did help with testing,
but we may be reaching a point where it's not worth it anymore.</p>
<p>Let's undo the <code>starmap</code> thing and validate it with a quick experiment
(this will obviously break non-4D, temporarily):</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>36
37
38
39
40
41
42</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>    <span class="k">for</span> <span class="n">offsets</span> <span class="ow">in</span> <span class="n">make_directions</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
        <span class="n">neighbor_coords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">coords</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="p">]</span>
</code></pre></div>
</td></tr></table><p>Which gives us a 50% improvement!</p>
<pre class="code code-container"><code>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     4096    0.203    0.000    0.208    0.000 conway-cubes.py:30(get_active_neighbors)
33938/8194    0.011    0.000    0.011    0.000 conway-cubes.py:58(ndenumerate)
</code></pre>
<p>Let's make everything non-generic, and get rid of needless intermediary variables:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">get_active_neighbors</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
    <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span> <span class="o">=</span> <span class="n">coords</span>

    <span class="k">if</span> <span class="n">c0</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">c1</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">c2</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">c3</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;active on edge: </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">active_neighbors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">o0</span><span class="p">,</span> <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">o3</span> <span class="ow">in</span> <span class="n">make_directions</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">active_neighbors</span> <span class="o">+=</span> <span class="n">world</span><span class="p">[</span><span class="n">o0</span> <span class="o">+</span> <span class="n">c0</span><span class="p">][</span><span class="n">o1</span> <span class="o">+</span> <span class="n">c1</span><span class="p">][</span><span class="n">o2</span> <span class="o">+</span> <span class="n">c2</span><span class="p">][</span><span class="n">o3</span> <span class="o">+</span> <span class="n">c3</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;active on edge: </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">active_neighbors</span>
</code></pre></div>
</td></tr></table><p>That yields a 75% improvement!</p>
<pre class="code code-container"><code>     4096    0.095    0.000    0.095    0.000 conway-cubes.py:30(get_active_neighbors)
33938/8194    0.011    0.000    0.011    0.000 conway-cubes.py:49(ndenumerate)
</code></pre>
<h2 id="going-multidimensional-again">Going multidimensional, again<span class="headerlink"> <a href="#going-multidimensional-again" title="permalink">#</a></span></h2>
<p>At this point, we could be OK with part of the code not being generic anymore,
implement one <code>get_active_neighbors()</code> per dimension, and use them like this:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="n">GET_ACTIVE_NEIGHBORS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">2</span><span class="p">:</span> <span class="n">get_active_neighbors_2d</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">:</span> <span class="n">get_active_neighbors_3d</span><span class="p">,</span>
    <span class="mi">4</span><span class="p">:</span> <span class="n">get_active_neighbors_4d</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">get_active_neighbors</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">GET_ACTIVE_NEIGHBORS</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)](</span><span class="n">world</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</code></pre></div>
<p>This reminds me of the pattern initially proposed for <code>make_directions()</code>...
If only there was a way to do the same thing for a function.</p>
<p>Well, this is Python, we <em>can</em> generate code at runtime;
let's do something <em>stupid</em>:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>3</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">make_get_active_neighbors_str</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">        def get_active_neighbors(world, active, coords):</span>
<span class="s2">            </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;c</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> = coords</span>

<span class="s2">            if </span><span class="si">{</span><span class="s1">&#39; or &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;c</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> &lt; 1&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">)</span><span class="si">}</span><span class="s2">:</span>
<span class="s2">                if active:</span>
<span class="s2">                    raise RuntimeError(f&quot;active on edge: </span><span class="se">{{</span><span class="s2">coords</span><span class="se">}}</span><span class="s2">&quot;)</span>

<span class="s2">            active_neighbors = 0</span>
<span class="s2">            for </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;o</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">make_directions</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span><span class="si">}</span><span class="s2">:</span>
<span class="s2">                try:</span>
<span class="s2">                    active_neighbors += world[</span><span class="si">{</span><span class="s1">&#39;][&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;o</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> + c</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">)</span><span class="si">}</span><span class="s2">]</span>
<span class="s2">                except IndexError:</span>
<span class="s2">                    if active:</span>
<span class="s2">                        raise RuntimeError(f&quot;active on edge: </span><span class="se">{{</span><span class="s2">coords</span><span class="se">}}</span><span class="s2">&quot;)</span>

<span class="s2">            return active_neighbors</span>

<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

<span class="nd">@lru_cache</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">make_get_active_neighbors</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="n">context</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">exec</span><span class="p">(</span><span class="n">make_get_active_neighbors_str</span><span class="p">(</span><span class="n">dimensions</span><span class="p">),</span> <span class="n">context</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">context</span><span class="p">[</span><span class="s1">&#39;get_active_neighbors&#39;</span><span class="p">]</span>
</code></pre></div>
</td></tr></table><p>Hey, that's the same <a href="https://docs.python.org/3/library/functions.html#exec">exec</a> we used
to work around <code>conway-cubes.py</code> not being importable!
(yup, I left that &quot;issue&quot; there for foreshadowing purposes)</p>
<p>Unlike in the test file, we use an explicit globals dictionary,
to avoid polluting the global namespace
(everything that gets defined in the source code string is a <code>context</code> item).</p>
<p>You may also notice that we're embedding the representation of the directions list
directly in the code, instead of calling <code>make_directions()</code>;
I'm not sure this brings a great speed-up, but it can't hurt.</p>
<section class="admonition attention">
<div class="admonition-text">
<p>Never use <a href="https://docs.python.org/3/library/functions.html#exec">exec</a>/eval with untrusted code,
 unless you want to get hacked;
 <a href="https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html">details</a>.</p>
<p>Security issues aside, it makes code way harder to understand,
 and breaks a lot of conventions about where classes and functions come from;
 <a href="https://lucumr.pocoo.org/2011/2/1/exec-in-python/">more details</a>.</p>
<p>We're doing it here for ... didactic purposes.
 And speed. Mostly speed.</p>
</div>
</section>
<p>Before we try it out, let's pull the dimension counting heuristic
from <code>ndenumerate()</code> into a separate function:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>61
62
63
64
65
66
67
68
69
70
71</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">guess_dimensions</span><span class="p">(</span><span class="n">world</span><span class="p">):</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">dimensions</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">world</span> <span class="o">=</span> <span class="n">world</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dimensions</span>

<span class="k">def</span> <span class="nf">ndenumerate</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="n">dimensions</span> <span class="ow">or</span> <span class="n">guess_dimensions</span><span class="p">(</span><span class="n">world</span><span class="p">)</span>

    <span class="c1"># ...</span>
</code></pre></div>
</td></tr></table><p>Using it leaves us with something that's slighly faster than our initial experiment:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>81
82
83
84
85
86</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="n">guess_dimensions</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
    <span class="n">get_active_neighbors</span> <span class="o">=</span> <span class="n">make_get_active_neighbors</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">coords</span><span class="p">,</span> <span class="n">active</span> <span class="ow">in</span> <span class="n">ndenumerate</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
        <span class="c1"># ...</span>
</code></pre></div>
</td></tr></table><pre class="code code-container"><code>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     4096    0.090    0.000    0.090    0.000 &lt;string&gt;:3(get_active_neighbors)
33946/8196    0.010    0.000    0.010    0.000 conway-cubes.py:62(ndenumerate)
</code></pre>
<p>Since we now have slightly different implementations,
let's parametrize the edge error test so that we check all the dimensions:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>33
34
35
36</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">test_edge_errors</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
        <span class="n">run</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">dedent</span><span class="p">(</span><span class="nb">input</span><span class="p">)),</span> <span class="n">cycles</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>
</td></tr></table><h2 id="the-real-world">The real world<span class="headerlink"> <a href="#the-real-world" title="permalink">#</a></span></h2>
<p>So, with our profiling <code>test 8 4 1</code>,
we got a 91% (~11x) improvement in <code>get_active_neighbors()</code> run time.</p>
<p>Does this reflect in the real-world performance?</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$</span> python conway-cubes.py real <span class="m">20</span> <span class="m">4</span> <span class="m">6</span>
<span class="go">after cycle #0 (0.01s): ...</span>
<span class="go">after cycle #1 (3.39s): ...</span>
<span class="go">after cycle #2 (3.43s): ...</span>
<span class="go">after cycle #3 (3.34s): ...</span>
<span class="go">after cycle #4 (3.34s): ...</span>
<span class="go">after cycle #5 (3.34s): ...</span>
<span class="go">after cycle #6 (3.35s): ...</span>
<span class="go">the result is 2276 (20.21s)</span>
</code></pre></div>
<p>Almost; that's still an 86% (~7x) improvement.</p>
<h2 id="bonus-pypy">Bonus: PyPy<span class="headerlink"> <a href="#bonus-pypy" title="permalink">#</a></span></h2>
<p><a href="https://www.pypy.org/">PyPy</a> is an alternative Python implementation that's
often faster than CPython (the standard implementation)
due to its use of <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">just-in-time compilation</a>.</p>
<p>Currently, it works mostly out of the box for Python code up to version 3.7
(with the exception of some CPython extensions).</p>
<p>First, let's see how it performs on our on the unoptimized script:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$</span> pypy3 conway-cubes-prep-work.py real <span class="m">20</span> <span class="m">4</span> <span class="m">6</span>
<span class="go">after cycle #0 (0.02s): ...</span>
<span class="go">after cycle #1 (6.43s): ...</span>
<span class="go">after cycle #2 (5.53s): ...</span>
<span class="go">after cycle #3 (5.47s): ...</span>
<span class="go">after cycle #4 (5.45s): ...</span>
<span class="go">after cycle #5 (5.47s): ...</span>
<span class="go">after cycle #6 (5.46s): ...</span>
<span class="go">the result is 2276 (33.82s)</span>
</code></pre></div>
<p>4.2x; not bad, for essentially zero work!
Funnily enough, their website says that
<em>&quot;on average, PyPy is 4.2 times faster than CPython&quot;</em>.</p>
<p>So, was it all for nothing, could have we just used PyPy from the start?
Yes and no, but mostly no:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$</span> pypy3 conway-cubes.py real <span class="m">20</span> <span class="m">4</span> <span class="m">6</span>
<span class="go">after cycle #0 (0.02s): ...</span>
<span class="go">after cycle #1 (0.52s): ...</span>
<span class="go">after cycle #2 (0.33s): ...</span>
<span class="go">after cycle #3 (0.33s): ...</span>
<span class="go">after cycle #4 (0.33s): ...</span>
<span class="go">after cycle #5 (0.34s): ...</span>
<span class="go">after cycle #6 (0.33s): ...</span>
<span class="go">the result is 2276 (2.21s)</span>
</code></pre></div>
<p>That's a 10x improvement over the same script run with CPython,
4.2x over the unoptimized script with PyPy,
and 65x over the unoptimized script with CPython!</p>
<h2 id="conclusions">Conclusions<span class="headerlink"> <a href="#conclusions" title="permalink">#</a></span></h2>
<p><a href="https://wiki.c2.com/?ProfileBeforeOptimizing">Profile before optimizing</a>.
Most often, your intuition about where the code is slow is wrong.</p>
<p>Many small optimizations add up.
It's easy to get stuck where there are no other small optimization left;
sometimes, a different algorithm is better than many small optimizations.</p>
<p><a href="https://docs.python.org/3/faq/programming.html#my-program-is-too-slow-how-do-i-speed-it-up">My program is too slow. How do I speed it up?</a> has more better advice.</p>
<p>Optimizations come with costs.
Usually, optimizations make code harder to understand.
More changes increases the likelihood of bugs.
More changes on harder to understand code even more so.
Tests help you know you're not breaking anything.
Profiling helps minimize the amount of code you change.</p>
<p>PyPy is amazing, give it a try sometime.</p>
<p>Function calls are slow in Python;
that only matters if you're calling them millions of times.</p>
<p>Python has code generation, and you can do cool stuff with it.
Most of the time, <em>it's not worth it</em>.</p>
<h2 id="bonus-other-things-i-tried">Bonus: other things I tried<span class="headerlink"> <a href="#bonus-other-things-i-tried" title="permalink">#</a></span></h2>
<p>making the world bigger by 2, and never passing the edges to get_active_neighbors (which didn't do any check); even without the checks, <code>20 4 6</code> was only 1 second faster; it might be better for bigger things.</p>
<pre class="code code-container"><code>try:
    for {', '.join(f'o{i}' for i in ids)} in {make_directions(dimensions)}:
        active_neighbors += world[{']['.join(f'o{i} + c{i}' for i in ids)}]
except IndexError:
    if active:
        raise RuntimeError(f&quot;active on edge: {{coords}}&quot;)
</code></pre>
<p>Didn't do anything on pypy! needed more tests</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$</span> pypy3 conway-cubes.py real <span class="m">20</span> <span class="m">4</span> <span class="m">6</span>
<span class="go">after cycle #0 (0.02s): ...</span>
<span class="go">after cycle #1 (0.56s): ...</span>
<span class="go">after cycle #2 (0.35s): ...</span>
<span class="go">after cycle #3 (0.34s): ...</span>
<span class="go">after cycle #4 (0.35s): ...</span>
<span class="go">after cycle #5 (0.35s): ...</span>
<span class="go">after cycle #6 (0.34s): ...</span>
<span class="go">the result is 2228 (2.32s)</span>

<span class="gp">$</span> python conway-cubes.py real <span class="m">20</span> <span class="m">4</span> <span class="m">6</span>
<span class="go">after cycle #0 (0.02s): ...</span>
<span class="go">after cycle #1 (2.98s): ...</span>
<span class="go">after cycle #2 (3.49s): ...</span>
<span class="go">after cycle #3 (3.05s): ...</span>
<span class="go">after cycle #4 (3.06s): ...</span>
<span class="go">after cycle #5 (3.12s): ...</span>
<span class="go">after cycle #6 (3.05s): ...</span>
<span class="go">the result is 2228 (18.77s)</span>
</code></pre></div>







</div>
</main>


<footer class="footer">
<p class="text-gray">
<a href="/">home</a>
∙ <a href="/_feed/index.xml">feed</a>
∙ <a href="/about">about</a>

∙ © 2021 lemon24
</footer>


</div>