






<!doctype html>

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/_static/spectre.css">
<link rel="stylesheet" href="/_static/pygments.css">
<link rel="stylesheet" href="/_static/style.css">

<link rel="alternate" type="application/atom+xml" title="Atom feed" href="/_feed/index.xml" />

<link rel="icon" href="/_static/xo-system-icon.svg">
<link rel="apple-touch-icon" href="/_static/xo-system-icon.svg">







<title>Caching methods - death and gravity</title>




<script>
/* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
function set_vh() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}
/* we do it once, now, *and* on every resize */
set_vh();
window.addEventListener('resize', set_vh);
</script>





<div class="main container grid-lg">


<header>
<nav>
<ul class="breadcrumb">

<li class="breadcrumb-item">
    <a href="/">death and gravity</a>
</li>

</ul>
</nav>

<h1 class="heading-noindex">Caching methods</h1>

<p class="text-gray text-nowrap">



<small>
<span class="tooltip" data-tooltip="published on 2023-02-23">February 2023</span>
∙ five minute read
∙
</small><span class="share-icons">
<a
    class="share-icon twitter"
    href="https://twitter.%63%6f%6d/%73%68%61%72%65?text=Caching%20methods&url=https%3A//death.andgravity.com/caching-methods&via=_andgravity"
>Twitter</a>
<a
    class="share-icon hacker-news"
    href="https://news.ycombinator.%63%6f%6d/submitlink?u=https%3A//death.andgravity.com/caching-methods&t=Caching%20methods"
>HN</a>
<a
    class="share-icon reddit"
    href="https://www.reddit.%63%6f%6d/%73%75%62%6d%69%74?url=https%3A//death.andgravity.com/caching-methods&title=Caching%20methods"
>Reddit</a>
</span>


</p>






</header>


<main class="content columns">
<div class="column col-sm-12 col-md-10 col-8">

<p>TODO: intro</p>
<section class="toc">
<ul>
<li><a href="#subclassing">Subclassing</a></li>
<li><a href="#but-decorating-methods-keeps-instances-around-for-too-long">But decorating methods keeps instances around for too long</a></li>
<li><a href="#but-i-need-to-cache-a-lot-of-methods">But I need to cache a lot of methods</a></li>
<li><a href="#but-the-object-is-already-instantiated">But the object is already instantiated</a></li>
<li><a href="#but-proxy-breaks-completion">But Proxy breaks completion</a></li>
<li><a href="#but-proxy-fails-isinstance-checks">But Proxy fails isinstance() checks</a></li>
<li><a href="#but-i-only-need-to-cache-a-few-methods">But I only need to cache a few methods</a></li>
</ul>
</section>
<p>For the sake of simplicity,
we'll assume we're using a client that looks like this;
in practice, there would lots of other methods and attributes.</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">class</span> <span class="nc">Client</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Client.method(</span><span class="si">{</span><span class="n">arg</span><span class="si">!r}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
</code></pre></div>

<p>We'll use <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache">functools.lru_cache()</a>.</p>
<h2 id="subclassing">Subclassing<span class="headerlink"> <a href="#subclassing" title="permalink">#</a></span></h2>
<p>If Client was our code,
we could just slap a <code>@functools.lru_cache</code> on <code>method()</code>.</p>
<p>The next best thing is to subclass it,
extend <code>method()</code>, decorate that.</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">class</span> <span class="nc">Subclass</span><span class="p">(</span><span class="n">Client</span><span class="p">):</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
</code></pre></div>

<h2 id="but-decorating-methods-keeps-instances-around-for-too-long">But decorating methods keeps instances around for too long<span class="headerlink"> <a href="#but-decorating-methods-keeps-instances-around-for-too-long" title="permalink">#</a></span></h2>
<p>As the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache">lru_cache()</a> docs say,</p>
<blockquote>
<p>If a method is cached, the <code>self</code> instance argument is included in the cache. See <a href="https://docs.python.org/3/faq/programming.html#faq-cache-method-calls">How do I cache method calls?</a></p>
</blockquote>
<p>... which in turn says:</p>
<blockquote>
<p>The <em>lru_cache</em> approach [...] creates a reference to the instance unless special efforts are made to pass in weak references. [...] The disadvantage is that instances are kept alive until they age out of the cache or until the cache is cleared.</p>
</blockquote>
<p>Depending on how often Client is instantiated,
this <em>might</em> count as a memory and/or resource leak.
For more details, see <a href="https://rednafi.github.io/reflections/dont-wrap-instance-methods-with-functoolslru_cache-decorator-in-python.html" title="Don't wrap instance methods with 'functools.lru_cache' decorator in Python">this article</a>.</p>
<p>One solution is to decorate the bound method
<em>after</em> the object is created:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">class</span> <span class="nc">SubclassOverwriteMethod</span><span class="p">(</span><span class="n">Client</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
</code></pre></div>

<p>This way, the instance is not in the cache keys,
and we have one cache per instance.</p>
<p>There's still a reference cycle between the cache and the instance
(via the bound method),
but the garbage collector will take care of that
– normally, all three go away at the same time.
Before, we had a cycle between the cache and the instance
<em>via the class</em>, which never goes away. TODO: wording</p>
<section class="admonition important">
<p class="admonition-title">Important</p>
<p>You might be tempted to say,
 &quot;but if I call <code>method(arg)</code> on two different instances,
 the underlying method will be called twice&quot;.</p>
<p>This is true, but it is by design. TODO: explain why</p>
</section>
<h2 id="but-i-need-to-cache-a-lot-of-methods">But I need to cache a lot of methods<span class="headerlink"> <a href="#but-i-need-to-cache-a-lot-of-methods" title="permalink">#</a></span></h2>
<p>OK, the above works, but every time we want to cache a new method,
we have to add it to <code>__init__()</code> ...
if there's a lot of them,
it might be a <em>bit</em> inconvenient.</p>
<p>Thankfully, Python allows us to do it on the fly:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">class</span> <span class="nc">SubclassProxy</span><span class="p">(</span><span class="n">Client</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># conveniently, also prevents infinite recursion</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(),</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(),</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="n">cached</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)(</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cached</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cached</span>
</code></pre></div>

<p><a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__">__getattribute__()</a> is called
&quot;unconditionally to implement attribute accesses&quot;
(including methods).
When a method is requested,
we get it from the parent class,
decorate it,
and store it in the instance dictionary;
the second time around,
we return the already decorated method.</p>
<p>We don't decorate any method whose names start with an underscore;
this includes any <a href="https://docs.python.org/3/glossary.html#term-magic-method"><code>__magic__</code> methods</a>,
and any <code>_private</code> methods the parent may have.
Special logic around the method name can also go here
(e.g. only cache methods starting with <code>get_</code>, or
cache all methods except those starting with <code>set_</code>).</p>
<p>Note we cannot use <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__">__getattr__()</a>
(called only &quot;when the default attribute access fails&quot;),
because looking up an attribute on the parent class
<em>is</em> part of default attribute access
(so <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__">__getattr__()</a> won't be called if the method is found).</p>
<p>We <em>could</em> just decorate the parent methods upfront, in  <code>__init__()</code>,
but IMHO the <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattribute__">__getattribute__()</a> makes the intention clearer.
Also, it might not work if the parent class does magic stuff
and doesn't implement <a href="https://docs.python.org/3/reference/datamodel.html#object.__dir__">__dir__()</a> properly.</p>
<h2 id="but-the-object-is-already-instantiated">But the object is already instantiated<span class="headerlink"> <a href="#but-the-object-is-already-instantiated" title="permalink">#</a></span></h2>
<p>Sometimes, you might not be the one instantiating the object;
they may be created through a <a href="https://python-patterns.guide/gang-of-four/abstract-factory/#the-pythonic-approach-callable-factories">callable factory</a>,
or you might just get them passed to you by a framework.</p>
<p>No worries, subclassing is not required for Python metaprogramming –
instead of subclassing,
we can wrap the instance in an object proxy
(also known as <a href="https://python-patterns.guide/gang-of-four/decorator-pattern/#implementing-dynamic-wrapper">dynamic wrapper</a>).</p>
<p>The code looks more or less the same as before,
but instead of delegating to the parent,
we delegate to the <em>wrapped</em> instance:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">class</span> <span class="nc">Proxy</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wrapped__</span> <span class="o">=</span> <span class="n">wrapped</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__wrapped__</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="n">cached</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)(</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cached</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cached</span>
</code></pre></div>

<p>Because the proxy is a separate object from the instance,
now we <em>can</em> use <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__">__getattr__()</a>,
and we don't have to check the instance dictionary explicitly –
on the second call, the decorated method is already there,
and <a href="https://docs.python.org/3/reference/datamodel.html#object.__getattr__">__getattr__()</a> isn't called again.</p>
<h2 id="but-proxy-breaks-completion">But Proxy breaks completion<span class="headerlink"> <a href="#but-proxy-breaks-completion" title="permalink">#</a></span></h2>
<p>Oops,
we're guilty of the not implementing <a href="https://docs.python.org/3/reference/datamodel.html#object.__dir__">__dir__()</a> correctly mentioned before,
which, among others, breaks completion:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">Proxy</span><span class="p">(</span><span class="n">Client</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;method&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;method&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">client</span><span class="o">.</span><span class="n">__wrapped__</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.&lt;</span><span class="n">TAB</span><span class="o">&gt;</span>
<span class="go">           ... crickets ...</span>
</code></pre></div>
<p>This is easily fixed:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code>    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__wrapped__</span><span class="p">)</span>
</code></pre></div>

<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">Proxy</span><span class="p">(</span><span class="n">Client</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;method&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
<span class="go">True</span>
</code></pre></div>
<h2 id="but-proxy-fails-isinstance-checks">But Proxy fails isinstance() checks<span class="headerlink"> <a href="#but-proxy-fails-isinstance-checks" title="permalink">#</a></span></h2>
<p>As it turns out, <a href="https://python-patterns.guide/gang-of-four/decorator-pattern/#caveat-wrapping-doesnt-actually-work">it's pretty difficult to get an object proxy right</a>.</p>
<p>For example, although not recommended,
sometimes code does <a href="https://docs.python.org/3/library/functions.html#isinstance">isinstance()</a> checks:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">Client</span><span class="p">)</span>
<span class="go">False</span>
</code></pre></div>
<p>We could fix this by implementing <a href="https://docs.python.org/3/reference/datamodel.html#class.__instancecheck__">__instancecheck__()</a>,
but a more general approach is in order –
<a href="https://wrapt.readthedocs.io/en/latest/wrappers.html#object-proxy">wrapt</a> gives us an almost-perfect proxy:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">class</span> <span class="nc">WraptProxy</span><span class="p">(</span><span class="n">wrapt</span><span class="o">.</span><span class="n">ObjectProxy</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_self_cached_methods</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_self_cached_methods</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="n">cached</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_self_cached_methods</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cached</span>
        <span class="k">return</span> <span class="n">cached</span>
</code></pre></div>

<p>It's not as elegant as our own,
but think of all the things we didn't have to do:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">WraptProxy</span><span class="p">(</span><span class="n">Client</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span>
<span class="go">&lt;WraptProxy at 0x106c2f5c0 for Client at 0x106c2ec10&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;__main__.Client&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">Client</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;method&#39;</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
<span class="go">True</span>
</code></pre></div>
<h2 id="but-i-only-need-to-cache-a-few-methods">But I only need to cache a few methods<span class="headerlink"> <a href="#but-i-only-need-to-cache-a-few-methods" title="permalink">#</a></span></h2>
<p>OK, but all that seems a bit excessive if you only need to cache a couple of methods.
We could add logic for that, but it doesn't help with the excessiveness.</p>
<p>If we're the only ones using the client,
we can just go back to decorating the bound method.
... except, didn't we say the instance already exists?</p>
<p>So what? It's not like we can only assing a method in <code>__init__()</code>:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">cache_method_in_place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">cached</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="n">method</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cached</span><span class="p">)</span>

<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>
<span class="n">cache_method_in_place</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</code></pre></div>

<p>Unexpected? A bit.
Unholy? Maybe, depending where you're coming from.</p>
<p>But actually, no,
it's neither,
it still <a href="https://docs.python.org/3/glossary.html#term-duck-typing">walks and quacks</a> like a Client.
In the end, that's why people use Python
–
you can bring up the big guns of a full wrapper or metaprogramming,
but you're not forced to.</p>
<hr />
<p>Anyway, that's it for now.</p>
<p><strong>Learned something new today?</strong> Share this with others, it really helps! <span class="text-large">
<span class="share-icons">
<a
    class="share-icon twitter color"
    href="https://twitter.%63%6f%6d/%73%68%61%72%65?text=Caching%20methods&url=https%3A//death.andgravity.com/caching-methods&via=_andgravity"
>Twitter</a>
<a
    class="share-icon hacker-news color"
    href="https://news.ycombinator.%63%6f%6d/submitlink?u=https%3A//death.andgravity.com/caching-methods&t=Caching%20methods"
>HN</a>
<a
    class="share-icon reddit color"
    href="https://www.reddit.%63%6f%6d/%73%75%62%6d%69%74?url=https%3A//death.andgravity.com/caching-methods&title=Caching%20methods"
>Reddit</a>
</span>
</span></p>

<form
    action="https://gmail.us7.list-manage.com/subscribe/post?u=9909b0e978d8d8d941bd3c8dc&amp;id=c61d63d661&SIGNUP=caching-methods"
    method="post"
    id="embedded-subscribe-form"
    name="mc-embedded-subscribe-form"
    target="_blank"
    novalidate
    class="panel subscribe-form"
>
    <div class="panel-header text-large">

        Want to know when new articles come out?

    </div>
    <div class="panel-body">

        <p>Drop your email in the box below and I'll send new stuff straight to your inbox!</p>

        <div class="form-group col-6 col-xs-12 col-md-9">
        <input type="text" name="FNAME" id="mce-FNAME"
            class="form-input input-lg"
            placeholder="Your first name"
        >
        </div>

        <div class="form-group col-6 col-xs-12 col-md-9">
        <input type="email" name="EMAIL" id="mce-EMAIL"
            class="form-input input-lg"
            placeholder="Your email address"
        >
        </div>

        <!-- bot prevention-->
        <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_9909b0e978d8d8d941bd3c8dc_c61d63d661" tabindex="-1" value=""></div>

    </div>
    <div class="panel-footer">

        <div class="form-group">
        <input type="submit"  name="subscribe" id="mc-embedded-subscribe"
            class="btn btn-primary btn-lg"
            value="Subscribe"
        >
        </div>

    </div>

</form>








</div>
</main>


<footer class="footer">
<p class="text-gray">
<a href="/">home</a>
∙ <a href="/_feed/index.xml">feed</a>
∙ <a href="/about">about</a>

∙ © 2021 lemon24



</footer>


</div>