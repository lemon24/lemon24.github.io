






<!doctype html>

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/_static/spectre.css">
<link rel="stylesheet" href="/_static/pygments.css">
<link rel="stylesheet" href="/_static/style.css">

<link rel="alternate" type="application/atom+xml" title="Atom feed" href="/_feed/index.xml" />

<link rel="icon" href="/_static/xo-system-icon.svg">
<link rel="apple-touch-icon" href="/_static/xo-system-icon.svg">







<title>Caching methods - death and gravity</title>




<script>
/* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
function set_vh() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}
/* we do it once, now, *and* on every resize */
set_vh();
window.addEventListener('resize', set_vh);
</script>





<div class="main container grid-lg">


<header>
<nav>
<ul class="breadcrumb">

<li class="breadcrumb-item">
    <a href="/">death and gravity</a>
</li>

</ul>
</nav>

<h1 class="heading-noindex">Caching methods</h1>

<p class="text-gray text-nowrap">



<small>
<span class="tooltip" data-tooltip="published on 2023-02-23">February 2023</span>
∙ three minute read
∙
</small><span class="share-icons">
<a
    class="share-icon twitter"
    href="https://twitter.%63%6f%6d/%73%68%61%72%65?text=Caching%20methods&url=https%3A//death.andgravity.com/caching-methods&via=_andgravity"
>Twitter</a>
<a
    class="share-icon hacker-news"
    href="https://news.ycombinator.%63%6f%6d/submitlink?u=https%3A//death.andgravity.com/caching-methods&t=Caching%20methods"
>HN</a>
<a
    class="share-icon reddit"
    href="https://www.reddit.%63%6f%6d/%73%75%62%6d%69%74?url=https%3A//death.andgravity.com/caching-methods&title=Caching%20methods"
>Reddit</a>
</span>


</p>






</header>


<main class="content columns">
<div class="column col-sm-12 col-md-10 col-8">

<p>TODO: intro</p>
<section class="toc">
<ul>
<li><a href="#subclassing">Subclassing</a></li>
<li><a href="#but-decorating-methods-keeps-instances-around-for-too-long">But, decorating methods keeps instances around for too long</a></li>
<li><a href="#but-i-need-to-cache-a-lot-of-methods">But, I need to cache a lot of methods</a></li>
<li><a href="#but-i-don-t-instantiate-the-object">But, I don't instantiate the object</a></li>
<li><a href="#but-this-breaks-completion-fails-an-isinstance-check">But, this breaks completion / fails an isinstance() check</a></li>
<li><a href="#but-i-only-need-to-cache-a-few-methods">But, I only need to cache a few methods</a></li>
</ul>
</section>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">class</span> <span class="nc">Client</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Client.method&#39;</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
</code></pre></div>

<p>We'll use <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache">functools.lru_cache()</a>.</p>
<h2 id="subclassing">Subclassing<span class="headerlink"> <a href="#subclassing" title="permalink">#</a></span></h2>
<p>TODO: ...</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">class</span> <span class="nc">Subclass</span><span class="p">(</span><span class="n">Client</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
</code></pre></div>

<h2 id="but-decorating-methods-keeps-instances-around-for-too-long">But, decorating methods keeps instances around for too long<span class="headerlink"> <a href="#but-decorating-methods-keeps-instances-around-for-too-long" title="permalink">#</a></span></h2>
<p>As the <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache">lru_cache()</a> docs say,</p>
<blockquote>
<p>If a method is cached, the <code>self</code> instance argument is included in the cache. See <a href="https://docs.python.org/3/faq/programming.html#faq-cache-method-calls">How do I cache method calls?</a></p>
</blockquote>
<p>... which in turn says:</p>
<blockquote>
<p>The <em>lru_cache</em> approach [...] creates a reference to the instance unless special efforts are made to pass in weak references. [...] The disadvantage is that instances are kept alive until they age out of the cache or until the cache is cleared.</p>
</blockquote>
<p>Depending on how often Client is instantiated,
this <em>might</em> count as a memory and/or resource leak.
For more details, see <a href="https://rednafi.github.io/reflections/dont-wrap-instance-methods-with-functoolslru_cache-decorator-in-python.html" title="Don't wrap instance methods with 'functools.lru_cache' decorator in Python">this article</a>.</p>
<p>One solution is to decorate the bound method
<em>after</em> the object is created:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">class</span> <span class="nc">SubclassOverwriteMethod</span><span class="p">(</span><span class="n">Client</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
</code></pre></div>

<p>This way, the instance is not in the cache keys,
and we have one cache per instance.</p>
<p>There's still a reference cycle between the cache and the instance
(via the bound method),
but the garbage collector will take care of that
– normally, all three go away at the same time.
Before, we had a cycle between the cache and the instance
<em>via the class</em>, which never goes away.</p>
<section class="admonition important">
<p class="admonition-title">Important</p>
<p>You might be tempted to say,
 &quot;but if I call <code>method(arg)</code> on two different instances,
 the underlying method will be called twice&quot;.</p>
<p>This is true, but it is by design. TODO: explain why</p>
</section>
<h2 id="but-i-need-to-cache-a-lot-of-methods">But, I need to cache a lot of methods<span class="headerlink"> <a href="#but-i-need-to-cache-a-lot-of-methods" title="permalink">#</a></span></h2>
<p>TODO: ...</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">class</span> <span class="nc">SubclassProxy</span><span class="p">(</span><span class="n">Client</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># without this, we get infinite recursion</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(),</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(),</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="n">cached</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)(</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cached</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cached</span>
</code></pre></div>

<p>TODO: note difference between getattr and getattribute</p>
<h2 id="but-i-don-t-instantiate-the-object">But, I don't instantiate the object<span class="headerlink"> <a href="#but-i-don-t-instantiate-the-object" title="permalink">#</a></span></h2>
<p>TODO: ... (example: boto?)</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">class</span> <span class="nc">Proxy</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wrapped__</span> <span class="o">=</span> <span class="n">wrapped</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__wrapped__</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="n">cached</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)(</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cached</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cached</span>
</code></pre></div>

<h2 id="but-this-breaks-completion-fails-an-isinstance-check">But, this breaks completion / fails an isinstance() check<span class="headerlink"> <a href="#but-this-breaks-completion-fails-an-isinstance-check" title="permalink">#</a></span></h2>
<p>TODO: ...</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">class</span> <span class="nc">WraptProxy</span><span class="p">(</span><span class="n">wrapt</span><span class="o">.</span><span class="n">ObjectProxy</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__wrapped__</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="n">cached</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)(</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cached</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cached</span>
</code></pre></div>

<h2 id="but-i-only-need-to-cache-a-few-methods">But, I only need to cache a few methods<span class="headerlink"> <a href="#but-i-only-need-to-cache-a-few-methods" title="permalink">#</a></span></h2>
<p>We've come full circle, we're decorating the bound method again.</p>
<p>But this time, it's from the outside.</p>
<p>TODO: ...</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">cache_method_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">cached</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)(</span><span class="n">method</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cached</span><span class="p">)</span>


<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>
<span class="n">cache_method_inplace</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">)</span>
</code></pre></div>

<p>TODO: Weird? Yes. Unholy? Maybe? But in the end, this is why we use Python!</p>
<p>TODO: It's not actually that weird... (nothing changes) (does mypy complain?)</p>








</div>
</main>


<footer class="footer">
<p class="text-gray">
<a href="/">home</a>
∙ <a href="/_feed/index.xml">feed</a>
∙ <a href="/about">about</a>

∙ © 2021 lemon24



</footer>


</div>