<!doctype html>

<meta name="viewport" content="width=device-width" />


<link rel="stylesheet" href="/_static/spectre.css">
<link rel="stylesheet" href="/_static/pygments.css">
<link rel="stylesheet" href="/_static/style.css">

<link rel="alternate" type="application/atom+xml" title="Atom feed" href="/_feed/index.xml" />




<title>untitled - death and gravity</title>


<script>
/* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
function set_vh() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}
/* we do it once, now, *and* on every resize */
set_vh();
window.addEventListener('resize', set_vh);
</script>


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4RY2QR580X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', "G-4RY2QR580X");
</script>



<div class="main container grid-lg">


<header>
<nav>
<ul class="breadcrumb">

<li class="breadcrumb-item">
    <a href="/">death and gravity</a>
</li>

</ul>
</nav>

<h1>untitled</h1>

<p class="text-gray"><small>

</small></p>

</header>


<main class="content columns">
<div class="column col-sm-12 col-md-10 col-8">

<ul>
<li>in which we see how to calculate a stable hash for Python data objects<ul>
<li>stable across interpreter implementations and versions</li>
</ul>
</li>
</ul>
<details>
<summary>Contents</summary>
<section class="toc">
<ul>
<li><a href="#real-world-problem">real world problem</a></li>
<li><a href="#requirements">requirements</a></li>
<li><a href="#problem-stable-hash">problem: stable hash</a>
<ul>
<li><a href="#bad-solution-hash">bad solution: hash()</a></li>
<li><a href="#better-solution-hashlib">better solution: hashlib</a></li>
</ul>
</li>
<li><a href="#problem-stable-way-of-serializing-objects-to-bytes">problem: stable way of serializing objects to bytes</a>
<ul>
<li><a href="#bad-solution-pickle">bad solution: pickle</a></li>
<li><a href="#bad-solution-str-and-repr">bad solution: str() and repr()</a></li>
<li><a href="#better-solution-json">better solution: json</a></li>
</ul>
</li>
<li><a href="#problem-ignore-empty-value">problem: ignore empty value</a></li>
<li><a href="#problem-skip-fields">problem: skip fields</a></li>
<li><a href="#conclusion">conclusion</a></li>
</ul>
</section>
</details>
<h2 id="real-world-problem">real world problem<span class="headerlink"> <a href="#real-world-problem" title="permalink">#</a></span></h2>
<ul>
<li>assume you have a feed reader library (link)</li>
<li>you have a number of feeds, and each feed has entries (articles)</li>
<li>entries have an <code>updated</code> date</li>
<li>they are imported if <code>updated</code> date is newer than the stored <code>updated</code> date</li>
<li>the content of some entries changes, but their <code>updated</code> date doesn't;
we'd like them to be updated whenever the content changes,
regardless of whether their <code>updated</code> date changed or not</li>
</ul>
<p>minimal entry and content example, links to the real deal</p>
<h2 id="requirements">requirements<span class="headerlink"> <a href="#requirements" title="permalink">#</a></span></h2>
<ol>
<li>stable hash across interpreter implementations and versions<ol>
<li>support (almost) arbitrary <em>data</em> objects</li>
<li>be safe (if I pass the wrong object by mistake, I should know)</li>
</ol>
</li>
<li>ignore &quot;empty&quot; values (to be able to add new without changing hash)</li>
<li>skip some of the fields (in reality, I only found this much later)</li>
</ol>
<h2 id="problem-stable-hash">problem: stable hash<span class="headerlink"> <a href="#problem-stable-hash" title="permalink">#</a></span></h2>
<h3 id="bad-solution-hash">bad solution: hash()<span class="headerlink"> <a href="#bad-solution-hash" title="permalink">#</a></span></h3>
<ul>
<li>explain what it does</li>
<li>not stable (nor guaranteed), randomization; with examples</li>
<li>requires object to be hashable; acceptable for my use case, idk about the future</li>
</ul>
<h3 id="better-solution-hashlib">better solution: hashlib<span class="headerlink"> <a href="#better-solution-hashlib" title="permalink">#</a></span></h3>
<ul>
<li>explain what it does</li>
<li>problem: it takes bytes</li>
</ul>
<h2 id="problem-stable-way-of-serializing-objects-to-bytes">problem: stable way of serializing objects to bytes<span class="headerlink"> <a href="#problem-stable-way-of-serializing-objects-to-bytes" title="permalink">#</a></span></h2>
<h3 id="bad-solution-pickle">bad solution: pickle<span class="headerlink"> <a href="#bad-solution-pickle" title="permalink">#</a></span></h3>
<ul>
<li>looks good</li>
<li>until it doesn't: datetime hashes differenty</li>
<li>some versions hash the same</li>
<li>however, no guarantees, can't trust it</li>
</ul>
<h3 id="bad-solution-str-and-repr">bad solution: str() and repr()<span class="headerlink"> <a href="#bad-solution-str-and-repr" title="permalink">#</a></span></h3>
<ul>
<li>unsafe – everything has a str() or repr(), they are not always good</li>
<li>not guaranteed to have all of the content</li>
<li>in reality, I skipped directly to pickle</li>
</ul>
<h3 id="better-solution-json">better solution: json<span class="headerlink"> <a href="#better-solution-json" title="permalink">#</a></span></h3>
<ul>
<li>problem: by default it only supports dicts, lists, etc.; no datetime, no user-defined classes</li>
<li>solution: json.dumps(deafult=...), dataclasses.asdict()</li>
</ul>
<p>example code, interactive session</p>
<p>safety:</p>
<ul>
<li>supports dataclasses (which already declare &quot;these are the data attribetus); we coudl use <code>__dict__</code>, but it might pick up other stuff</li>
<li>supports datetime</li>
<li>supports nothing else</li>
</ul>
<p>for better safety, we could also include the type, but good enough for now</p>
<p>for better safety, we could limit the dataclass types it knows about, YAGNI</p>
<h2 id="problem-ignore-empty-value">problem: ignore empty value<span class="headerlink"> <a href="#problem-ignore-empty-value" title="permalink">#</a></span></h2>
<p>explain why this is needed, with code example: Class vs NewClass</p>
<p>solution: dataclasses.asdict(dict_factory=...)</p>
<p>code example, get_hash(class) == get_hash(newclass)</p>
<h2 id="problem-skip-fields">problem: skip fields<span class="headerlink"> <a href="#problem-skip-fields" title="permalink">#</a></span></h2>
<p>could do it in json_default</p>
<p>problem: would be ok for our use case, but would not work for nested dataclasses; if possible, the code should be as generic as possible</p>
<p>solution: have classes tell us if they want something skipped</p>
<p>can't do it with asdict():  recursive and we need to intercept and check
the <code>_hash_exclude_</code> of nested dataclasses; we implement a non-recursive version of asdict();
this way, json.dumps() does the recursion instead of asdict()</p>
<p>code example</p>
<h2 id="conclusion">conclusion<span class="headerlink"> <a href="#conclusion" title="permalink">#</a></span></h2>
<p>link to the real deal</p>
<p>decent tradeoff between generality and safety</p>
<p>something else?</p>
<p>maybe mention future proofing with version</p>
<!--

https://stackoverflow.com/questions/5583907/is-the-builtin-hash-method-of-python2-6-stable-across-architectures
https://stackoverflow.com/questions/27522626/hash-function-in-python-3-3-returns-different-results-between-sessions
https://stackoverflow.com/questions/46768213/how-to-hash-a-class-or-function-definition
https://stackoverflow.com/questions/6550660/python-are-hash-values-for-built-in-numeric-types-strings-standardised


-->







</div>
</main>


<footer class="footer">
<p class="text-gray">
<a href="/">home</a>
∙ <a href="/_feed/index.xml">feed</a>
∙ <a href="/about">about</a>

∙ © 2021 lemon24
</footer>


</div>