












<!doctype html>

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/_static/spectre.css">
<link rel="stylesheet" href="/_static/pygments.css">
<link rel="stylesheet" href="/_static/style.css">

<link rel="alternate" type="application/atom+xml" title="Atom feed" href="/_feed/index.xml" />

<link rel="icon" href="/_static/xo-system-icon.svg">
<link rel="apple-touch-icon" href="/_static/xo-system-icon.svg">







<title>Backpressure: or, how parallel map() accidentally the whole thing - death and gravity</title>



<meta property="og:title" content="Backpressure: or, how parallel map() accidentally the whole thing">
<meta property="og:site_name" content="death and gravity">
<meta property="og:type" content="article">
<meta property="og:url" content="https://death.andgravity.com/imap-backpressure">




<script>
/* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
function set_vh() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}
/* we do it once, now, *and* on every resize */
set_vh();
window.addEventListener('resize', set_vh);
</script>





<div class="main container grid-lg">


<header>
<nav>
<ul class="breadcrumb">

<li class="breadcrumb-item">
    <a href="/">death and gravity</a>
</li>

</ul>
</nav>

<h1 class="heading-noindex">Backpressure: or, how parallel map() accidentally the whole thing</h1>

<p class="text-gray text-nowrap">



<small>
<span class="tooltip" data-tooltip="published on 2024-03-27">March 2024</span>
∙ two minute read
∙
</small><span class="share-icons">
<a
    class="share-icon pycoders"
    href="https://pycoders.com/submissions"
    target="_blank"
>PyCoder's Weekly</a>
<a
    class="share-icon hacker-news"
    href="https://news.ycombinator.%63%6f%6d/submitlink?u=https%3A//death.andgravity.com/imap-backpressure&t=Backpressure%3A%20or%2C%20how%20parallel%20map%28%29%20accidentally%20the%20whole%20thing"
>HN</a>
<a
    class="share-icon reddit"
    href="https://www.reddit.%63%6f%6d/%73%75%62%6d%69%74?url=https%3A//death.andgravity.com/imap-backpressure&title=Backpressure%3A%20or%2C%20how%20parallel%20map%28%29%20accidentally%20the%20whole%20thing"
>Reddit</a>
<a
    class="share-icon linkedin"
    href="https://www.linkedin.%63%6f%6d/sharing/share-offsite/?url=https%3A//death.andgravity.com/imap-backpressure"
>linkedin</a>
<a
    class="share-icon twitter"
    href="https://twitter.%63%6f%6d/%73%68%61%72%65?text=Backpressure%3A%20or%2C%20how%20parallel%20map%28%29%20accidentally%20the%20whole%20thing&url=https%3A//death.andgravity.com/imap-backpressure&via=_andgravity"
>Twitter</a>
</span>


</p>






</header>


<main class="content columns">
<div class="column col-sm-12 col-md-10 col-8">

<p>Say you're processing a lazy iterable in parallel
with <a class="external" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap">Pool.imap()</a> or <a class="external" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered">imap_unordered()</a>.</p>
<p>Maybe you get things in an &quot;endless&quot; stream from a paginated API,
download them in parallel, and save progress to a database.
Maybe it's more complicated, and
you have multiple parallel processing steps chained in a sort of pipeline.</p>
<!--
```python
inputs = get_inputs()
ones = pool.imap(do_one, inputs)
twos = pool.imap(do_two, ones)
threes = pool.imap(do_three, twos)
outputs = list(threes)
```
-->
<p>What happens if you <strong>consume results slower than things are processed</strong>?
Maybe the database is slow today, 
or the second processing step is much slower than the first.</p>
<p>A reasonable intuition is that <strong>workers block
until the next result is requested</strong>
– that is, workers process results in lockstep with the consumer.
You may also expect that
<strong>workers get items from the input iterable as needed</strong>
– after all, that's how vanilla non-parallel <a class="external" href="https://docs.python.org/3/library/functions.html#map">map()</a> works, right?</p>
<p>Both intuitions <strong>are wrong</strong>.</p>
<!-- .. toc:: -->
<h2 id="an-example">An example<span class="headerlink">&nbsp;<a href="#an-example" title="permalink">#</a></span></h2>
<p>Here's a simplified version of the problem:
<code>range(3)</code> is the stream,
<code>do_thing()</code> the processor,
and we're using just one thread to make what's happening clear.</p>
<p>First, the &quot;normal&quot; case, when consuming results is fast:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">do_thing</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;done:&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">i</span>
<span class="gp">... </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">dummy</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">do_thing</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; out:&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">done: 0</span>
<span class="go"> out: 0</span>
<span class="go">done: 1</span>
<span class="go"> out: 1</span>
<span class="go">done: 2</span>
<span class="go"> out: 2</span>
</code></pre></div>
<p>Items are processed by each worker one at a time,
and results are yielded by the <a class="external" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap_unordered">imap_unordered()</a> iterator
as soon as they're ready. So far so good.</p>
<p>So, if our intuition is correct,
we get the same output for a slow consumer, right?</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">do_thing</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; out:&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">done: 0</span>
<span class="go">done: 1</span>
<span class="go">done: 2</span>
<span class="go"> out: 0</span>
<span class="go"> out: 1</span>
<span class="go"> out: 2</span>
</code></pre></div>
<p><strong>Wrong!</strong>
The workers keep doing work,
even when the consumer remains behind.</p>
<p>Following the same intuition,
you may expect that
<strong>workers get items from the input iterable as needed</strong>...
alas, you'd be <strong>wrong again</strong>:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">get_inputs</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  in:&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">yield</span> <span class="n">i</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span><span class="n">do_thing</span><span class="p">,</span> <span class="n">get_inputs</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; out:&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">  in: 0</span>
<span class="go">  in: 1</span>
<span class="go">  in: 2</span>
<span class="go">done: 0</span>
<span class="go">done: 1</span>
<span class="go">done: 2</span>
<span class="go"> out: 0</span>
<span class="go"> out: 1</span>
<span class="go"> out: 2</span>
</code></pre></div>
<p>TODO: memory</p>
<!--
import time, multiprocessing.dummy

pool = multiprocessing.dummy.Pool(1)

for result in pool.imap_unordered(do_thing, range(3)):
    print(' out:', result)

for result in pool.imap_unordered(do_thing, range(3)):
    time.sleep(.2)
    print(' out:', result)

for result in pool.imap_unordered(do_thing, get_inputs(3)):
    time.sleep(.2)
    print(' out:', result)
-->
<!-- TODO separate performance section for double and chunk size -->
<h2 id="what-is-backpressure">What is backpressure?<span class="headerlink">&nbsp;<a href="#what-is-backpressure" title="permalink">#</a></span></h2>
<p>&quot;when code consuming results from [i]map_unordered() cannot keep up with the tasks producing them, the results accumulate in the internal queue, with potentially infinite memory usage&quot;</p>
<figure class="figure">
<svg xmlns='http://www.w3.org/2000/svg' class="pikchr" viewBox="0 0 514.556 40.6694">
<path d="M220.868,32.4L305.907,32.4L305.907,2.16L220.868,2.16Z"  style="fill:rgb(255,255,255);stroke-width:2.16;stroke:rgb(0,0,0);" />
<path d="M217.813,35.4547L302.852,35.4547L302.852,5.2147L217.813,5.2147Z"  style="fill:rgb(255,255,255);stroke-width:2.16;stroke:rgb(0,0,0);" />
<path d="M2.16,38.5094L87.1994,38.5094L87.1994,8.2694L2.16,8.2694Z"  style="fill:rgb(255,255,255);stroke-width:2.16;stroke:rgb(0,0,0);" />
<text x="44.6797" y="23.3894" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">input</text>
<polygon points="87.1994,23.3894 98.7194,19.0694 98.7194,27.7094" style="fill:rgb(0,0,0)"/>
<path d="M92.9594,23.3894L214.758,23.3894"  style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);" />
<path d="M214.758,38.5094L299.798,38.5094L299.798,8.2694L214.758,8.2694Z"  style="fill:rgb(255,255,255);stroke-width:2.16;stroke:rgb(0,0,0);" />
<text x="257.278" y="23.3894" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">worker</text>
<polygon points="299.798,23.3894 311.318,19.0694 311.318,27.7094" style="fill:rgb(0,0,0)"/>
<path d="M305.558,23.3894L427.357,23.3894"  style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);" />
<path d="M427.357,38.5094L512.396,38.5094L512.396,8.2694L427.357,8.2694Z"  style="fill:rgb(255,255,255);stroke-width:2.16;stroke:rgb(0,0,0);" />
<text x="469.877" y="23.3894" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">for</text>
</svg>


<figcaption class="figure-caption text-center text-small">
</figcaption>
</figure>
<figure class="figure">
<svg xmlns='http://www.w3.org/2000/svg' class="pikchr" viewBox="0 0 514.556 40.6694">
<path d="M220.868,32.4L305.907,32.4L305.907,2.16L220.868,2.16Z"  style="fill:rgb(255,255,255);stroke-width:2.16;stroke:rgb(0,0,0);" />
<path d="M217.813,35.4547L302.852,35.4547L302.852,5.2147L217.813,5.2147Z"  style="fill:rgb(255,255,255);stroke-width:2.16;stroke:rgb(0,0,0);" />
<path d="M2.16,38.5094L87.1994,38.5094L87.1994,8.2694L2.16,8.2694Z"  style="fill:rgb(255,255,255);stroke-width:2.16;stroke:rgb(0,0,0);" />
<text x="44.6797" y="23.3894" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">input</text>
<polygon points="121.215,23.3894 109.695,27.7094 109.695,19.0694" style="fill:rgb(0,0,0)"/>
<path d="M87.1994,23.3894L115.455,23.3894"  style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);" />
<path d="M134.319,36.4934L167.639,36.4934A13.104 13.104 0 0 0 180.743 23.3894A13.104 13.104 0 0 0 167.639 10.2854L134.319,10.2854A13.104 13.104 0 0 0 121.215 23.3894A13.104 13.104 0 0 0 134.319 36.4934Z"  style="fill:rgb(255,255,255);stroke-width:2.16;stroke:rgb(0,0,0);" />
<text x="150.979" y="23.3894" text-anchor="middle" fill="rgb(0,0,0)" font-size="80%" dominant-baseline="central">queue</text>
<polygon points="180.743,23.3894 192.263,19.0694 192.263,27.7094" style="fill:rgb(0,0,0)"/>
<path d="M186.503,23.3894L214.758,23.3894"  style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);" />
<path d="M214.758,38.5094L299.798,38.5094L299.798,8.2694L214.758,8.2694Z"  style="fill:rgb(255,255,255);stroke-width:2.16;stroke:rgb(0,0,0);" />
<text x="257.278" y="23.3894" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">worker</text>
<polygon points="333.814,23.3894 322.294,27.7094 322.294,19.0694" style="fill:rgb(0,0,0)"/>
<path d="M299.798,23.3894L328.054,23.3894"  style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);" />
<path d="M346.918,36.4934L380.237,36.4934A13.104 13.104 0 0 0 393.341 23.3894A13.104 13.104 0 0 0 380.237 10.2854L346.918,10.2854A13.104 13.104 0 0 0 333.814 23.3894A13.104 13.104 0 0 0 346.918 36.4934Z"  style="fill:rgb(255,255,255);stroke-width:2.16;stroke:rgb(0,0,0);" />
<text x="363.577" y="23.3894" text-anchor="middle" fill="rgb(0,0,0)" font-size="80%" dominant-baseline="central">queue</text>
<polygon points="393.341,23.3894 404.861,19.0694 404.861,27.7094" style="fill:rgb(0,0,0)"/>
<path d="M399.101,23.3894L427.357,23.3894"  style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);" />
<path d="M427.357,38.5094L512.396,38.5094L512.396,8.2694L427.357,8.2694Z"  style="fill:rgb(255,255,255);stroke-width:2.16;stroke:rgb(0,0,0);" />
<text x="469.877" y="23.3894" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">for</text>
</svg>


</figure>
<p>https://bugs.python.org/issue40110</p>
<h2 id="queue">Queue<span class="headerlink">&nbsp;<a href="#queue" title="permalink">#</a></span></h2>
<p>internally, it uses a queue; if we had access to the queue,
we could easily fix this by making the queue bounded.</p>
<p>indeed, <a class="internal" href="/limit-concurrency#aside-backpressure">this solution works</a>
for a <a class="internal" href="/limit-concurrency#asyncio-queue">similar set-up using asyncio</a></p>
<p>https://nedbatchelder.com/blog/202008/do_a_pile_of_work.html#comment_16232</p>
<h2 id="concurrent-futures">concurrent.futures<span class="headerlink">&nbsp;<a href="#concurrent-futures" title="permalink">#</a></span></h2>
<p>if you're not tied to multiprocessing,
there's another solution, based on concurrent.futures,
and it has backpressure built-in</p>
<p>... code</p>
<p>this probably has less overhead,
and is also good if you want to use it
<a class="internal" href="/imap-concurrent">somewhere where multiprocessing doesn't work</a>,
like AWS Lambda.</p>
<p>even better, because the concurrent.futures API is similar to that of asyncio,
you can use a <a class="internal" href="/limit-concurrency#asyncio-wait">similar solution</a>
to get backpressure there too!</p>








</div>
</main>


<footer class="footer">
<p class="text-gray">
<a href="/">home</a>
∙ <a href="/_feed/index.xml">feed</a>
∙ <a href="/about">about</a>

∙ © 2021 lemon24



</footer>


</div>