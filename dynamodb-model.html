












<!doctype html>

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/_static/spectre.css">
<link rel="stylesheet" href="/_static/pygments.css">
<link rel="stylesheet" href="/_static/style.css">

<link rel="alternate" type="application/atom+xml" title="Atom feed" href="/_feed/index.xml" />

<link rel="icon" href="/_static/xo-system-icon.svg">
<link rel="apple-touch-icon" href="/_static/xo-system-icon.svg">







<title>DynamoDB crash course: part 2 – data model - death and gravity</title>



<meta property="og:title" content="DynamoDB crash course: part 2 – data model">
<meta property="og:site_name" content="death and gravity">
<meta property="og:type" content="article">
<meta property="og:url" content="https://death.andgravity.com/dynamodb-model">




<script>
/* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
function set_vh() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}
/* we do it once, now, *and* on every resize */
set_vh();
window.addEventListener('resize', set_vh);
</script>





<div class="main container grid-lg">


<header>
<nav>
<ul class="breadcrumb">

<li class="breadcrumb-item">
    <a href="/">death and gravity</a>
</li>

</ul>
</nav>

<h1 class="heading-noindex">DynamoDB crash course: part 2 – data model</h1>

<p class="text-gray text-nowrap">



<small>
<span class="tooltip" data-tooltip="published on 2025-12-19">December 2025</span>
∙ 12 minute read
∙
</small><span class="share-icons">
<a
    class="share-icon pycoders"
    href="https://pycoders.com/submissions"
    target="_blank"
>PyCoder's Weekly</a>
<a
    class="share-icon hacker-news"
    href="https://news.ycombinator.%63%6f%6d/submitlink?u=https%3A//death.andgravity.com/dynamodb-model&t=DynamoDB%20crash%20course%3A%20part%202%20%E2%80%93%20data%20model"
>HN</a>
<a
    class="share-icon bluesky"
    href="https://bsky.%61%70%70/intent/compose?text=DynamoDB%20crash%20course%3A%20part%202%20%E2%80%93%20data%20model%20https%3A//death.andgravity.com/dynamodb-model"
>Bluesky</a>
<!--
<a
    class="share-icon reddit"
    href="https://www.reddit.%63%6f%6d/%73%75%62%6d%69%74?url=https%3A//death.andgravity.com/dynamodb-model&title=DynamoDB%20crash%20course%3A%20part%202%20%E2%80%93%20data%20model"
>Reddit</a>
-->
<a
    class="share-icon linkedin"
    href="https://www.linkedin.%63%6f%6d/sharing/share-offsite/?url=https%3A//death.andgravity.com/dynamodb-model"
>linkedin</a>
<a
    class="share-icon twitter"
    href="https://twitter.%63%6f%6d/%73%68%61%72%65?text=DynamoDB%20crash%20course%3A%20part%202%20%E2%80%93%20data%20model&url=https%3A//death.andgravity.com/dynamodb-model&via=_andgravity"
>Twitter</a>
</span>


</p>






</header>


<main class="content columns">
<div class="column col-sm-12 col-md-10 col-8">

<details class="toc" open>
<summary>Table of Contents</summary>
<ul>
<li><a href="#core-components">Core components</a>
<ul>
<li><a href="#api-model-tables-items-attributes">API model: tables, items, attributes</a></li>
<li><a href="#logical-model-hash-table-of-b-trees">Logical model: hash table of B‍-‍trees</a></li>
<li><a href="#physical-model-partitions">Physical model: partitions</a></li>
</ul>
</li>
<li><a href="#limits">Limits</a>
<ul>
<li><a href="#partition-throughput">Partition throughput</a></li>
<li><a href="#item-size">Item size</a></li>
<li><a href="#page-size">Page size</a></li>
</ul>
</li>
<li><a href="#indexes">Indexes</a>
<ul>
<li><a href="#global-secondary-indexes">Global secondary indexes</a></li>
<li><a href="#local-secondary-indexes">Local secondary indexes</a></li>
</ul>
</li>
<li><a href="#features">Features</a>
<ul>
<li><a href="#eventual-consistency">Eventual consistency</a></li>
<li><a href="#conditional-updates">Conditional updates</a></li>
<li><a href="#transactions">Transactions</a></li>
<li><a href="#batch-operations">Batch operations</a></li>
<li><a href="#streams">Streams</a></li>
</ul>
</li>
</ul>
</details>
<h2 id="core-components">Core components<span class="headerlink">&nbsp;<a href="#core-components" title="permalink">#</a></span></h2>
<p>According to the <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html">documentation</a>,
the core components of DynamoDB are tables, items, and attributes.
This is accurate in the sense of <strong>what you can act on</strong> through the API,
but can be deceptively simple,
and leaves out two other equally important aspects:
<strong>what you can do with it</strong> (the <em>logical model</em>)
and <strong>how it scales</strong> (the <em>physical model</em>).</p>
<p>Let's put it all together, starting from the top.</p>
<figure class="figure">

<svg xmlns='http://www.w3.org/2000/svg' style='font-size:initial;' class="pikchr" viewBox="0 0 655.2 371.098" data-pikchr-date="20260102012653">
<path d="M3.6,329.76L651.6,329.76A1.44 1.44 0 0 0 653.04 328.32L653.04,3.6A1.44 1.44 0 0 0 651.6 2.16L3.6,2.16A1.44 1.44 0 0 0 2.16 3.6L2.16,328.32A1.44 1.44 0 0 0 3.6 329.76Z"  style="fill:rgb(230,230,250);stroke-width:2.16;stroke:rgb(102,51,153);" />
<path d="M18,315.36L487.44,315.36A1.44 1.44 0 0 0 488.88 313.92L488.88,39.6A1.44 1.44 0 0 0 487.44 38.16L18,38.16A1.44 1.44 0 0 0 16.56 39.6L16.56,313.92A1.44 1.44 0 0 0 18 315.36Z"  style="fill:rgb(255,228,225);stroke-width:1.4472;stroke:rgb(255,0,0);stroke-dasharray:4.32,4.32;" />
<path d="M32.4,300.96L323.28,300.96A1.44 1.44 0 0 0 324.72 299.52L324.72,97.2A1.44 1.44 0 0 0 323.28 95.76L32.4,95.76A1.44 1.44 0 0 0 30.96 97.2L30.96,299.52A1.44 1.44 0 0 0 32.4 300.96Z"  style="fill:rgb(230,230,250);stroke-width:2.16;stroke:rgb(102,51,153);" />
<path d="M46.8,286.56L159.12,286.56A1.44 1.44 0 0 0 160.56 285.12L160.56,162A1.44 1.44 0 0 0 159.12 160.56L46.8,160.56A1.44 1.44 0 0 0 45.36 162L45.36,285.12A1.44 1.44 0 0 0 46.8 286.56Z"  style="fill:rgb(230,230,250);stroke-width:2.16;stroke:rgb(102,51,153);" />
<path d="M61.2,221.76L144.72,221.76A1.44 1.44 0 0 0 146.16 220.32L146.16,198A1.44 1.44 0 0 0 144.72 196.56L61.2,196.56A1.44 1.44 0 0 0 59.76 198L59.76,220.32A1.44 1.44 0 0 0 61.2 221.76Z"  style="fill:rgb(255,255,255);stroke-width:0;stroke:rgb(30,144,255);" />
<text x="102.96" y="209.16" text-anchor="middle" fill="rgb(30,144,255)" dominant-baseline="central">attribute</text>
<path d="M61.2,246.96L144.72,246.96A1.44 1.44 0 0 0 146.16 245.52L146.16,223.2A1.44 1.44 0 0 0 144.72 221.76L61.2,221.76A1.44 1.44 0 0 0 59.76 223.2L59.76,245.52A1.44 1.44 0 0 0 61.2 246.96Z"  style="fill:rgb(255,255,255);stroke-width:0;stroke:rgb(30,144,255);" />
<text x="102.96" y="234.36" text-anchor="middle" fill="rgb(30,144,255)" dominant-baseline="central">attribute</text>
<path d="M61.2,272.16L144.72,272.16A1.44 1.44 0 0 0 146.16 270.72L146.16,248.4A1.44 1.44 0 0 0 144.72 246.96L61.2,246.96A1.44 1.44 0 0 0 59.76 248.4L59.76,270.72A1.44 1.44 0 0 0 61.2 272.16Z"  style="fill:rgb(255,255,255);stroke-width:0;stroke:rgb(30,144,255);" />
<text x="102.96" y="259.56" text-anchor="middle" font-weight="bold" fill="rgb(30,144,255)" dominant-baseline="central">···</text>
<text x="51.12" y="175.68" text-anchor="start" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">item</text>
<path d="M176.4,286.56L259.92,286.56A1.44 1.44 0 0 0 261.36 285.12L261.36,162A1.44 1.44 0 0 0 259.92 160.56L176.4,160.56A1.44 1.44 0 0 0 174.96 162L174.96,285.12A1.44 1.44 0 0 0 176.4 286.56Z"  style="fill:rgb(230,230,250);stroke-width:2.16;stroke:rgb(102,51,153);" />
<text x="218.16" y="223.56" text-anchor="middle" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">···</text>
<text x="180.72" y="175.68" text-anchor="start" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">item</text>
<text x="293.04" y="223.56" text-anchor="middle" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">···</text>
<text x="36.72" y="110.88" text-anchor="start" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">collection (B-tree)</text>
<path d="M340.56,300.96L424.08,300.96A1.44 1.44 0 0 0 425.52 299.52L425.52,97.2A1.44 1.44 0 0 0 424.08 95.76L340.56,95.76A1.44 1.44 0 0 0 339.12 97.2L339.12,299.52A1.44 1.44 0 0 0 340.56 300.96Z"  style="fill:rgb(230,230,250);stroke-width:2.16;stroke:rgb(102,51,153);" />
<text x="382.32" y="198.36" text-anchor="middle" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">···</text>
<text x="344.88" y="110.88" text-anchor="start" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">collection</text>
<text x="457.2" y="198.36" text-anchor="middle" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">···</text>
<text x="22.32" y="53.28" text-anchor="start" fill="rgb(255,0,0)" dominant-baseline="central">partition</text>
<path d="M504.72,315.36L588.24,315.36A1.44 1.44 0 0 0 589.68 313.92L589.68,39.6A1.44 1.44 0 0 0 588.24 38.16L504.72,38.16A1.44 1.44 0 0 0 503.28 39.6L503.28,313.92A1.44 1.44 0 0 0 504.72 315.36Z"  style="fill:rgb(255,228,225);stroke-width:1.4472;stroke:rgb(255,0,0);stroke-dasharray:4.32,4.32;" />
<text x="546.48" y="176.76" text-anchor="middle" font-weight="bold" fill="rgb(255,0,0)" dominant-baseline="central">···</text>
<text x="509.04" y="53.28" text-anchor="start" fill="rgb(255,0,0)" dominant-baseline="central">partition</text>
<text x="621.36" y="176.76" text-anchor="middle" font-weight="bold" fill="rgb(255,0,0)" dominant-baseline="central">···</text>
<text x="7.92" y="17.28" text-anchor="start" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">table (hash table)</text>
<polygon points="218.16,160.56 215.266,152.842 221.054,152.842" style="fill:rgb(102,51,153)"/>
<path d="M218.16,156.701L218.16,146.16"  style="fill:none;stroke-width:1.4472;stroke:rgb(102,51,153);" />
<text x="218.16" y="133.56" text-anchor="middle" fill="rgb(102,51,153)" dominant-baseline="central">sort key</text>
<polygon points="102.96,160.56 100.066,152.842 105.854,152.842" style="fill:rgb(102,51,153)"/>
<path d="M102.96,156.701L102.96,146.16"  style="fill:none;stroke-width:1.4472;stroke:rgb(102,51,153);" />
<text x="102.96" y="133.56" text-anchor="middle" fill="rgb(102,51,153)" dominant-baseline="central">sort key</text>
<text x="160.56" y="133.56" text-anchor="middle" fill="rgb(102,51,153)" dominant-baseline="central">&lt;</text>
<polygon points="177.84,95.76 174.946,88.0416 180.734,88.0416" style="fill:rgb(102,51,153)"/>
<path d="M177.84,91.9008L177.84,81.36"  style="fill:none;stroke-width:1.4472;stroke:rgb(102,51,153);" />
<text x="177.84" y="68.76" text-anchor="middle" fill="rgb(102,51,153)" dominant-baseline="central">partition key</text>
<polygon points="382.32,95.76 379.426,88.0416 385.214,88.0416" style="fill:rgb(102,51,153)"/>
<path d="M382.32,91.9008L382.32,81.36"  style="fill:none;stroke-width:1.4472;stroke:rgb(102,51,153);" />
<text x="382.32" y="68.76" text-anchor="middle" fill="rgb(102,51,153)" dominant-baseline="central">partition key</text>
<path d="M4.02177,368.938L87.5418,368.938A1.44 1.44 0 0 0 88.9818 367.498L88.9818,345.178A1.44 1.44 0 0 0 87.5418 343.738L4.02177,343.738A1.44 1.44 0 0 0 2.58177 345.178L2.58177,367.498A1.44 1.44 0 0 0 4.02177 368.938Z"  style="fill:rgb(230,230,250);stroke-width:2.16;stroke:rgb(102,51,153);" />
<text x="45.7818" y="356.338" text-anchor="middle" fill="rgb(102,51,153)" font-size="80%" dominant-baseline="central">logical</text>
<path d="M97.6218,368.938L181.142,368.938A1.44 1.44 0 0 0 182.582 367.498L182.582,345.178A1.44 1.44 0 0 0 181.142 343.738L97.6218,343.738A1.44 1.44 0 0 0 96.1818 345.178L96.1818,367.498A1.44 1.44 0 0 0 97.6218 368.938Z"  style="fill:rgb(255,228,225);stroke-width:1.4472;stroke:rgb(255,0,0);stroke-dasharray:4.32,4.32;" />
<text x="139.382" y="356.338" text-anchor="middle" fill="rgb(255,0,0)" font-size="80%" dominant-baseline="central">physical only</text>
<path d="M191.222,368.938L274.742,368.938A1.44 1.44 0 0 0 276.182 367.498L276.182,345.178A1.44 1.44 0 0 0 274.742 343.738L191.222,343.738A1.44 1.44 0 0 0 189.782 345.178L189.782,367.498A1.44 1.44 0 0 0 191.222 368.938Z"  style="fill:rgb(255,255,255);stroke-width:0;stroke:rgb(30,144,255);" />
<text x="232.982" y="356.338" text-anchor="middle" fill="rgb(30,144,255)" font-size="80%" dominant-baseline="central">API only</text>
<text x="162.298" y="217.109" text-anchor="middle" fill="rgb(255,228,225)" font-size="64%" transform="rotate(90 162.298,223.56)" dominant-baseline="central">death.andgravity.com</text>
</svg>


</figure>

<h3 id="api-model-tables-items-attributes">API model: tables, items, attributes<span class="headerlink">&nbsp;<a href="#api-model-tables-items-attributes" title="permalink">#</a></span></h3>
<p>As far as the API is concerned,
&quot;a <strong>table</strong> is a collection of <strong>items</strong>,
and each item is a collection of <strong>attributes</strong>&quot;.<sup class="footnote-ref" id="fnref-1"><a href="#fn-1">1</a></sup></p>
<p>An item is uniquely identified by two attributes,
the <strong>partition key</strong> and the <strong>sort key</strong>,<sup class="footnote-ref" id="fnref-2"><a href="#fn-2">2</a></sup>
which together compose its <strong>primary key</strong>.<sup class="footnote-ref" id="fnref-3"><a href="#fn-3">3</a></sup>
A group of items with the same partition key value
is called an <strong>item collection</strong>,<sup class="footnote-ref" id="fnref-4"><a href="#fn-4">4</a></sup>
but this is more of a logical grouping,
and does not exist as a distinct entity in the API.</p>
<p>An attribute is a named data element,
with its value
either a scalar (number, string, binary, boolean, null),
a set of scalars,
or a document (a list or map of possibly nested attributes, similar to JSON).</p>
<p>There are no limits on table size or number of items,
nor on those of an item collection.
Items do have a <a class="anchor" href="#item-size">size limit</a> of 400 KB / item,
which indirectly affects attribute size.</p>
<p>As we've seen <a class="internal" href="/dynamodb#python-mockup">in the previous article</a>,
the core DynamoDB data operations are:</p>
<ul>
<li><code>PutItem</code>, <code>GetItem</code>, <code>UpdateItem</code>, <code>DeleteItem</code></li>
<li><code>Query</code> items with the same partition key, sorted by sort key,
and optionally narrowed down to a specific a range of sort keys</li>
<li><code>Scan</code> all the items in the table, possibly in parallel</li>
</ul>
<p>Besides whole items,
the API allows getting and updating specific attributes,
as well as filtering query and scan results by expressions using them.</p>
<!-- see also https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html -->

<h3 id="logical-model-hash-table-of-b-trees">Logical model: hash table of B‍-‍trees<span class="headerlink">&nbsp;<a href="#logical-model-hash-table-of-b-trees" title="permalink">#</a></span></h3>
<p>The operations above may seem arbitrarily restrictive
– for example, why can't I query items by sort key alone?
It might make more sense to think about it like this:</p>
<p>Conceptually,
a DynamoDB table is <strong>a <a class="external" href="https://en.wikipedia.org/wiki/Hash_table">hash table</a> of <a class="external" href="https://en.wikipedia.org/wiki/B-tree">B‍-‍trees</a></strong>,
with partition keys being hash table keys,
and sort keys being B‍-‍tree keys
(making <em>item collections</em> B‍-‍trees).
The hash table allows efficient <em>find collection by partition key</em> operations;
within each collection,
the B‍-‍tree keeps the items sorted,
and allows efficient <em>find item by sort key</em>
and <em>find items by sort key range</em> operations.</p>
<p>As a consequence,
<strong>any access not based on partition and sort key is expensive</strong>,
since instead of taking advantage of the underlying data structure,
you have to go through <em>all the items</em> in the table to find anything
(aka a <em>full table scan</em>),
and at the scales you'd use DynamoDB at,
this can mean billions of items.<sup class="footnote-ref" id="fnref-5"><a href="#fn-5">5</a></sup></p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p><small>(from <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#:~:text=another%20example%20table%20named%20Music">here</a>)</small>
Take a <em>Music</em> table where items correspond to songs,
with <em>Artist</em> as primary key and <em>Song</em> as sort key:</p>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># table Music (partition key: Artist, sort key: Song)</span>
<span class="nt">1000mods</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Claws</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Album</span><span class="p">:</span><span class="w"> </span><span class="nv">Vultures</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Vidage</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Year</span><span class="p">:</span><span class="w"> </span><span class="nv">2011</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">Kyuss</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Space Cadet</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
<p>You can efficiently:</p>
<ul>
<li>query songs by artist (sorted by song title)</li>
<li>get the song by artist and song title</li>
</ul>
<p>...and that's it, anything else requires a full table scan.</p>
</section>
<p>To a first approximation,
this is also a decent model of how DynamoDB scales
–
you could imagine that each collection has its own dedicated computer,
which in theory would account for the unlimited number of collections.</p>
<h3 id="physical-model-partitions">Physical model: partitions<span class="headerlink">&nbsp;<a href="#physical-model-partitions" title="permalink">#</a></span></h3>
<p>Of course, there are <em>not</em> infinitely many computers,
and that would be wildly inefficient anyway.
Instead, collections are packed together
into a smaller number of <strong>partitions</strong>, each a few gigabytes in size.
To figure out which partition an item should go on,
DynamoDB hashes its <em>partition key</em>
(also called a <em>hash key</em>, for obvious reasons).</p>
<p>This is kinda like hash table buckets,
except there's another level of indirection –
instead of mapping to a single number,
each partition maps to a range of numbers,
which allows splitting a partition into two new ones
by splitting its range.
Furthermore, an item collection
(that is, items with the same partition key)
can be split on multiple partitions too
by using the sort key.</p>
<p>And <em>that</em> is how the scaling magic happens:</p>
<ul>
<li>When you increase provisioned capacity,
partitions are added as needed.</li>
<li>If a partition or collection becomes too big,
it gets split.</li>
<li>If the <em>throughput</em> to a partition or collection
is high enough for long enough,
it also gets split,<sup class="footnote-ref" id="fnref-6"><a href="#fn-6">6</a></sup>
with a bias towards keys with higher utilization;
this was added <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DocumentHistory.html#:~:text=Adaptive%20capacity%20support%20for%20imbalanced%20workload">in 2019</a>.</li>
</ul>
<p>Partition management is handled entirely by DynamoDB
and is transparent to the user,
but it doesn't happen instantly –
it takes several minutes to allocate new partitions and shuffle things around.</p>
<p>Since they are backed by real computers,
partitions do have a <a class="anchor" href="#partition-throughput">throughput limit</a>.</p>
<!-- TODO: add these footnotes? -->

<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey">Core components # Primary key</a></li>
<li><small>(unofficial)</small> <a class="external" href="https://www.alexdebrie.com/posts/dynamodb-partitions">Everything you need to know about DynamoDB Partitions</a></li>
</ul>
</section>
<!-- see also

https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.Partitions.html
https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/burst-adaptive-capacity.html

https://aws.amazon.com/blogs/database/part-1-scaling-dynamodb-how-partitions-hot-keys-and-split-for-heat-impact-performance/
https://aws.amazon.com/blogs/database/part-2-scaling-dynamodb-how-partitions-hot-keys-and-split-for-heat-impact-performance/
https://aws.amazon.com/blogs/database/part-3-scaling-dynamodb-how-partitions-hot-keys-and-split-for-heat-impact-performance/

-->

<!-- TODO: make this an aside or a bonus

Depending on how you structure your data,
a DynamoDB table can correspond to either a single table or a whole database
in a relational database system.

Partitions are somewhat analogous to [shards],
but unlike with most relational databases,
partitions are built *into* the database,
rather than *on top* of it.

A DynamoDB item usually corresponds to a row in a relational database system.

A DynamoDB attribute corresponds to a field in a relational database system.

[shards]: https://en.wikipedia.org/wiki/Shard_(database_architecture)

-->

<h2 id="limits">Limits<span class="headerlink">&nbsp;<a href="#limits" title="permalink">#</a></span></h2>
<p>Part of DynamoDB's appeal is that
it <strong>scales &quot;infinitely&quot;</strong> for specific dimensions:
there are no limits on table size or number of items.
However, there are some hard, non-adjustable limits
you will have to take into account when designing your application.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/CheatSheet.html#CheatSheet.ServiceBasics">Cheat sheet # Service quota basics</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ServiceQuotas.html">Quotas</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Constraints.html">Constraints</a></li>
<li><small>(unofficial)</small> <a class="external" href="https://www.alexdebrie.com/posts/dynamodb-limits/">The Three DynamoDB Limits You Need to Know</a></li>
</ul>
</section>
<!--
TODO/IDEA: cheatsheet table a la big o cheatsheet
(one for table / partition / item )
(one for crud / batch / query/scan / transactions)

like so

| | read (ec) | read (sc) | write |
|-|-|-|-|
| units/s | 3,000 | 3,000 | 1,000 |
| unit size | 4 KB/unit | 4 KB/unit | 1 KB/unit |
| cost | 0.5 unit | 1 unit | 1 unit |
| total | 24 MB/s | 12 MB/s | 1 MB/s |

```
throughput = units/s * unit size * cost
```

-->

<h3 id="partition-throughput">Partition throughput<span class="headerlink">&nbsp;<a href="#partition-throughput" title="permalink">#</a></span></h3>
<p>The most important limit is
on partition throughput (aka <em>capacity</em>) –
how much data DynamoDB can read from or write
to a <a class="anchor" href="#physical-model-partitions">partition</a>
in a given amount of time:<sup class="footnote-ref" id="fnref-7"><a href="#fn-7">7</a></sup></p>
<ul>
<li><strong>1 MB/s for writes</strong></li>
<li><strong>24 MB/s for reads</strong>, <a class="anchor" href="#eventual-consistency">eventually consistent</a></li>
<li>12 MB/s for reads, strongly consistent</li>
</ul>
<p>Notably, this applies to
<strong>whole items DynamoDB has to access</strong>,
not the data that goes through the API.
While you can touch single attributes and filter query results,
the consumed capacity is always that
of the <em>whole</em> items DynamoDB had to read or write.<sup class="footnote-ref" id="fnref-8"><a href="#fn-8">8</a></sup></p>
<p>Once you reach the limit,
the operation will be throttled,
and you can try again later,
ideally with exponential backoff
(the AWS SDK usually takes care of this for you).</p>
<p>The best way to avoid throttling is
to <strong>distribute the load uniformly across partitions</strong>
by using a <strong>high-cardinality partition key</strong>.<sup class="footnote-ref" id="fnref-9"><a href="#fn-9">9</a></sup>
Uneven traffic can create <em>hot partitions</em>
that suffer from persistent throttling.</p>
<!-- TODO: should this be a footnote? -->

<p>Nowadays, uneven traffic is less of a problem.
For short-term imbalances like traffic spikes,
<a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/burst-adaptive-capacity.html#burst-capacity">burst capacity</a> and <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/burst-adaptive-capacity.html#adaptive-capacity">adaptive capacity</a>
will, <em>on a best effort basis</em>,
borrow capacity above the table capacity limit
and between partitions.
For long-term imbalances,
<a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/burst-adaptive-capacity.html#isolate-frequent-access-items">partition splitting</a>
should deal with the imbalance over time;
according to AWS,
you &quot;might&quot; even end up with a partition containing a single popular item.
However,
the documentation is very non-committal about their behaviour,
and there's no knobs you can tweak,
so <strong>good partition key design</strong> remains key.</p>
<p>Finally, it is worth noting that the throughput is fixed,
but the other dimensions are not;
thus, you have a trade-off between
<em>how often you access items</em>,
the <em>number of items</em>, and average <em>item size</em>.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.Partitions.html">Partitions and data distribution</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/read-write-operations.html">Read and write operations</a> (capacity unit consumption)</li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html">Partition key design</a><ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-uniform-load.html">Distributing workloads</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-sharding.html">Write sharding</a></li>
</ul>
</li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-sort-keys.html">Sort key design</a></li>
<li><small>(blog)</small> <a class="external" href="https://aws.amazon.com/blogs/database/choosing-the-right-dynamodb-partition-key/">Choosing the Right DynamoDB Partition Key</a></li>
</ul>
 <!-- https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/data-modeling-blocks.html#data-modeling-blocks-write-sharding -->

</section>
<h3 id="item-size">Item size<span class="headerlink">&nbsp;<a href="#item-size" title="permalink">#</a></span></h3>
<p>Second, the maximum size of an item is 400 KB.
This can be worked around by either splitting an item into multiple ones
on the same partition,
or by storing only the metadata in DynamoDB,
with data somewhere else, like S3
(this is a pretty common pattern).</p>
<!-- fixed but generous for most use cases, -->

<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Constraints.html#limits-items">Constraints # Items</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-use-s3-too.html">Large items</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/data-modeling-blocks.html#data-modeling-blocks-vertical-partitioning">Data modeling building blocks # Vertical partitioning building block</a></li>
</ul>
</section>
<h3 id="page-size">Page size<span class="headerlink">&nbsp;<a href="#page-size" title="permalink">#</a></span></h3>
<p>Finally, the result set of the query and scan operations
is limited to 1 MB per page,
but it is possible to stitch together multiple pages
by using a form of <a class="internal" href="/query-builder-why#intermission-scrolling-window-queries">keyset pagination</a>
(specifically, there's a <code>LastEvaluatedKey</code> that allows you to query/scan from the end of the previous page).</p>
<!-- link to eventual consistency -->

<p>However, this has implications on consistency,
especially for secondary indexes –
if an attribute used in a <abbr title="Global Secondary Index">GSI</abbr> primary or sort key changes,
an item can appear zero or multiple times in the entire (multi-page) result set.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Constraints.html#limits-api">Constraints # API-specific constraints</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.Pagination.html">Paginating query results</a></li>
</ul>
</section>
<h2 id="indexes">Indexes<span class="headerlink">&nbsp;<a href="#indexes" title="permalink">#</a></span></h2>
<p>When discussing tables,
I said that access not based on partition/sort key is expensive.
Secondary indexes allow other access patterns
by using an <strong>alternate primary key</strong>
composed of different attributes than that of the table.
You can query or scan an index just like you would a table.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.SecondaryIndexes">Core components # Secondary indexes</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SecondaryIndexes.html">Working with indexes</a></li>
</ul>
</section>
<h3 id="global-secondary-indexes">Global secondary indexes<span class="headerlink">&nbsp;<a href="#global-secondary-indexes" title="permalink">#</a></span></h3>
<p>Conceptually, a global secondary index is a separate table
that's automatically kept in sync with the base table,
and allows having different attributes as primary key.</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p><small>(from <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#:~:text=query%20the%20data%20by%20Genre%20and%20Album">here</a>)</small>
Continuing with the music example,
a <abbr title="Global Secondary Index">GSI</abbr> with <em>Genre</em> and <em>Album</em> as primary and sort key,
would allow you to <em>also</em> efficiently:</p>
<ul>
<li>query songs by genre
(and, if you collapse results in application code,
query albums by genre <em>somewhat</em> efficiently)</li>
<li>query songs by genre and album title
(but, two albums can have the same genre and title,
so you might want to group by artist in application code)</li>
</ul>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># table Music (partition key: Artist, sort key: Song)</span>
<span class="nt">Kyuss</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Demon Cleaner</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Album</span><span class="p">:</span><span class="w"> </span><span class="nv">Welcome To Sky Valley</span><span class="p p-Indicator">,</span><span class="nt"> Genre</span><span class="p">:</span><span class="w"> </span><span class="nv">Rock</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Space Cadet</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Album</span><span class="p">:</span><span class="w"> </span><span class="nv">Welcome To Sky Valley</span><span class="p p-Indicator">,</span><span class="nt"> Genre</span><span class="p">:</span><span class="w"> </span><span class="nv">Rock</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">1000mods</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Vidage</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Album</span><span class="p">:</span><span class="w"> </span><span class="nv">Super Van Vacation</span><span class="p p-Indicator">,</span><span class="nt"> Genre</span><span class="p">:</span><span class="w"> </span><span class="nv">Rock</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">Solar Fields</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Air Song</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Album</span><span class="p">:</span><span class="w"> </span><span class="nv">Leaving Home</span><span class="p p-Indicator">,</span><span class="nt"> Genre</span><span class="p">:</span><span class="w"> </span><span class="nv">Electronic</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># GSI Genres (partition key: Genre, sort key: Album)</span>
<span class="nt">Rock</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Super Van Vacation</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Artist</span><span class="p">:</span><span class="w"> </span><span class="nv">1000mods</span><span class="p p-Indicator">,</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Vidage</span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Welcome To Sky Valley</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Artist</span><span class="p">:</span><span class="w"> </span><span class="nv">Kyuss</span><span class="p p-Indicator">,</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Space Cadet</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Welcome To Sky Valley</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Artist</span><span class="p">:</span><span class="w"> </span><span class="nv">Kyuss</span><span class="p p-Indicator">,</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Demon Cleaner</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">Electronic</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Leaving Home</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Artist</span><span class="p">:</span><span class="w"> </span><span class="nv">Solar Fields</span><span class="p p-Indicator">,</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Air Song</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
</section>
<p>Aside from item partition and sort keys,
the index can include additional attributes,
so you can query the index alone;
this is called <strong><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html#GSI.Projections">attribute projection</a></strong>,
and is analogous to a <a class="external" href="https://en.wikipedia.org/wiki/Database_index#Covering_index">covering index</a> in relational databases;
however,
if you need an attribute that's not in the index,
you'll have to get it yourself from the base table
(batch operations can make this faster). <!-- TODO link --></p>
<p>Unlike real tables,
<abbr title="Global Secondary Index">GSI</abbr>s support only eventually consistent reads,
and their primary keys do not need to be unique.
In all other respects,
<strong><abbr title="Global Secondary Index">GSI</abbr>s behave like real tables</strong>:</p>
<ul>
<li>they have their own <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html#GSI.ThroughputConsiderations">separate capacity</a></li>
<li>they have no limits on size or the number of primary keys</li>
<li>they have the same <a class="anchor" href="#partition-throughput">partition throughput</a> limits,
and the same workarounds <!-- TODO link to sharding --></li>
</ul>
<p>You can have up to 20 <abbr title="Global Secondary Index">GSI</abbr>s per table,
although in practice you can reuse them.</p>
<!-- TODO link to overloading -->

<p>TODO: discuss <abbr title="Global Secondary Index">GSI</abbr> write throttling</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html">Global secondary indexes</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-indexes.html">Best practices for secondary indexes</a></li>
</ul>
</section>
<h3 id="local-secondary-indexes">Local secondary indexes<span class="headerlink">&nbsp;<a href="#local-secondary-indexes" title="permalink">#</a></span></h3>
<p>A local secondary index allows you to have an <strong>alternate sort key</strong> for a partition
(it is <em>local</em> to the partition).</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p>For the same <em>Music</em> with <em>Artist</em> as partition key,
a <abbr title="Local Secondary Index">LSI</abbr> with <em>Year</em> as sort key
would allow you to <em>also</em> efficiently:</p>
<ul>
<li>query songs by artist in chronological order</li>
<li>query songs by artist and year</li>
</ul>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># table Music (partition key: Artist, sort key: Song)</span>
<span class="nt">1000mods</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Claws</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Year</span><span class="p">:</span><span class="w"> </span><span class="nv">2014</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Road To Burn</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Year</span><span class="p">:</span><span class="w"> </span><span class="nv">2011</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Vidage</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Year</span><span class="p">:</span><span class="w"> </span><span class="nv">2011</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">Solar Fields</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Sombrero</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Year</span><span class="p">:</span><span class="w"> </span><span class="nv">2011</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># table Music (partition key: Artist, LSI sort key: Year)</span>
<span class="nt">1000mods</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">2011</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Vidage</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">2011</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Road To Burn</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">2014</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Claws</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">Solar Fields</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">2011</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Sombrero</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
</section>
<p>Unlike <abbr title="Global Secondary Index">GSI</abbr>s, local secondary indexes support
retrieving attributes <em>not</em> projected into the index
(with higher latency and cost),
and strongly consistent reads.</p>
<p>However, <abbr title="Local Secondary Index">LSI</abbr>s have their downsides:
they can only be created/deleted with the table,
and <strong>using <abbr title="Local Secondary Index">LSI</abbr>s limits partition size to 10 GB</strong>
(the size of the items in the table plus the items in <abbr title="Local Secondary Index">LSI</abbr>s);
because of this, people usually prefer using <abbr title="Global Secondary Index">GSI</abbr>s.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LSI.html">Local secondary indexes</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-indexes.html">Best practices for secondary indexes</a></li>
</ul>
</section>
<h2 id="features">Features<span class="headerlink">&nbsp;<a href="#features" title="permalink">#</a></span></h2>
<p>Before we go into how to structure data for efficient use with DynamoDB,
let's look at some of the things you can do with tables
besides simple <abbr title="create, read, update, and delete">CRUD</abbr> operations.</p>
<h3 id="eventual-consistency">Eventual consistency<span class="headerlink">&nbsp;<a href="#eventual-consistency" title="permalink">#</a></span></h3>
<p>By default, when reading an item,
the result may be a slightly older version of the data than the most current one;
if you repeat the read, you will eventually get the most recent item,
i.e. reads are <strong>eventually consistent</strong>.
(In part, this is a consequence DynamoDB replicating your data in <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html#ddb-intro-resilience">multiple availability zones</a>
– the node you're talking to may have not gotten the most recent data yet.)</p>
<p>For tables and <abbr title="Local Secondary Index">LSI</abbr>s, you can issue strongly-consistent reads,
which will give you the most up-to-date data;
these are slower, and twice as expensive.</p>
<p>To deal with the lack of a point-in time consistent view of the entire database,
DynamoDB offers <a class="anchor" href="#conditional-updates">conditional updates</a>,
as well as a limited form of <a class="anchor" href="#transactions">transactions</a>,
which serve as a sort of synchronization primitives.</p>
<p>Note that strongly-consistent reads do not remove
the need for synchronization primitives
– by the time you get the response,
the data may have already been updated by another processl
instead,
strong consistency is useful
to lower the rate at which conditional updates or transactions fail.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html">DynamoDB read consistency</a></li>
</ul>
</section>
<p>https://aws.amazon.com/blogs/database/part-2-scaling-dynamodb-how-partitions-hot-keys-and-split-for-heat-impact-performance/</p>
<blockquote>
<p>Every partition has its data spread across three nodes for redundancy—a leader node that takes all writes, and two follower nodes that follow quickly behind. A strongly consistent (SC) read always goes to the leader node to get the latest data. The leader node can handle 3,000 reads per second, which is why a partition can handle 3,000 SC reads per second. An EC read can go to any of the three nodes. When all three nodes are active, a partition can theoretically handle 9,000 reads per second, which is what we find here.</p>
</blockquote>
<h3 id="conditional-updates">Conditional updates<span class="headerlink">&nbsp;<a href="#conditional-updates" title="permalink">#</a></span></h3>
<p>For write operations (put/update/delete),
you can specify a <strong>condition expression</strong>
(e.g. an attribute exists, or has a specific value)
that must be true for the operation to happen;
if the expression evaluates to false,
the write fails.</p>
<p>Condition expressions are crucial for ensuring consistency
(and avoiding <a class="external" href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">time-of-check to time-of-use</a> bugs),
since they are the only way to run a bit of logic &quot;server-side&quot;,
on the <em>current</em> version of an item.
Note that the condition can refer only to the item being modified.</p>
<p>Higher level things can be built on top of condition expressions,
including <a class="internal" href="/dynamodb-patterns#optimistic-locking">optimistic locking</a> and <a class="external" href="https://github.com/awslabs/amazon-dynamodb-lock-client">distributed locks</a>.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ConditionExpressions.html">DynamoDB condition expression CLI example</a></li>
<li><small>(unofficial)</small> <a class="external" href="https://www.alexdebrie.com/posts/dynamodb-condition-expressions/">Understanding DynamoDB Condition Expressions</a></li>
</ul>
</section>
<h3 id="transactions">Transactions<span class="headerlink">&nbsp;<a href="#transactions" title="permalink">#</a></span></h3>
<p>Transactions allow performing write operations (put/update/delete)
to up to 100 items as a single all-or-nothing operation –
either all of them succeed, or none do.
The items can be in the same or <em>different</em> tables
in the same account and region.</p>
<p>Transactions also work with <a class="anchor" href="#conditional-updates">condition expressions</a>,
so if a condition fails for one item,
none of the items are modified.
If you want to evaluate a condition for an item that you're not modifying,
you can use the special <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ConditionCheck.html">ConditionCheck</a> operation.
Just like with single condition expressions,
the expressions can only refer to each item individually
(you can't have a condition about two items in the transaction).</p>
<p>You can also read up to 100 items transactionally
(to ensure serialization with transactional writes).</p>
<!-- * transactional operations consume twice as much capacity -->

<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/transactions.html">Working with transactions</a></li>
</ul>
</section>
<h3 id="batch-operations">Batch operations<span class="headerlink">&nbsp;<a href="#batch-operations" title="permalink">#</a></span></h3>
<p>You can put/delete up to 25 items or get up to 100 items
in a single request up to 16 MB in size;
this allows reading / writing / deleting large amounts of data efficiently.</p>
<p>The operations within a batch are entirely independent from one another –
some of the operations may fail / a partial result may be returned
(e.g. if <a class="anchor" href="#partition-throughput">throughput limits</a> are reached).
Also, batch writes don't support condition expressions.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchGetItem.html">BatchGetItem</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html">BatchWriteItem</a></li>
</ul>
</section>
<h3 id="streams">Streams<span class="headerlink">&nbsp;<a href="#streams" title="permalink">#</a></span></h3>
<p>Streams are DynamoDB's <a class="external" href="https://en.wikipedia.org/wiki/Change_data_capture">change data capture</a> mechanism,
and allow you to get notified in &quot;near-real time&quot;
when an item is created, updated, or deleted.
There are two flavors of streams,
<a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html">DynamoDB Streams</a> (the original one)
and <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/kds.html">Kinesis Data Streams</a> (integration with Amazon Kinesis).</p>
<p>Two notable applications of streams are:</p>
<ul>
<li>Lambda triggers (similar to triggers in relational databases)</li>
<li>replication to other places like S3 or Redshift (via Firehose)</li>
</ul>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.Streams">Core components # DynamoDB Streams</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/streamsmain.html">Working with streams</a></li>
<li><small>(unofficial)</small> <a class="external" href="https://www.alexdebrie.com/bites/dynamodb-streams/">What you should know about DynamoDB Streams</a></li>
</ul>
</section>
<section class="footnotes">
<ol>
<li id="fn-1"><p>Here, &quot;collection&quot; just means a &quot;group of things&quot;. <a href="#fnref-1" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-2"><p>Ignore the names for now, it'll make sense in a bit. <a href="#fnref-2" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-3"><p>It is also possible to have
a table with only a partition key and no sort key,
but you can think of that like
a degenerate case where the sort key is a constant value,
and thus each partition key can have only one item. <a href="#fnref-3" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-4"><p>Yes, an <em>item collection</em> is different from a &quot;collection of items&quot;.
Don't look at me, it wasn't me that picked the names. ಠ_ಠ <a href="#fnref-4" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-5"><p><a class="anchor" href="#indexes">Indexes</a>, which we'll discuss later,
offer an escape hatch to this. <a href="#fnref-5" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-6"><p>Assuming the table has enough configured throughput. <a href="#fnref-6" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-7"><p>Converted to normal people units for your convenience.
DynamoDB uses its own <em>capacity units</em>
as a convoluted way of saying that for accounting purposes,
item size is rounded up to 4 KB (1 <abbr title="Read Capacity Units">RCU</abbr>) for reads
and 1 KB (1 <abbr title="Write Capacity Units">WCU</abbr>) for writes.
This is presumably because the size of a capacity unit
<a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DocumentHistory.html#:~:text=4%20KB%20read%20capacity%20unit%20size">can increase</a> over time. <a href="#fnref-7" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-8"><p>Yes, this includes just counting them. <a href="#fnref-8" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-9"><p>If there is no good natural partition key,
you can manufacture one through sharding, <!-- TODO: link -->
which we'll cover in the next article. <a href="#fnref-9" class="footnote"><sup>[return]</sup></a></p></li>
</ol>
</section>








</div>
</main>


<footer class="footer">
<p class="text-gray">
<a href="/">home</a>
∙ <a href="/_feed/index.xml">feed</a>
∙ <a href="/about">about</a>

∙ © 2021 lemon24



</footer>


</div>