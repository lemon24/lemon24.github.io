












<!doctype html>

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/_static/spectre.css">
<link rel="stylesheet" href="/_static/pygments.css">
<link rel="stylesheet" href="/_static/style.css">

<link rel="alternate" type="application/atom+xml" title="Atom feed" href="/_feed/index.xml" />

<link rel="icon" href="/_static/xo-system-icon.svg">
<link rel="apple-touch-icon" href="/_static/xo-system-icon.svg">







<title>DynamoDB crash course: part 2 – data model - death and gravity</title>
<meta name="description" content="This is part one of a series covering core DynamoDB concepts and patterns, all the way up to single-table design; the goal is to get you to understand idiomatic usage and trade-offs in under an hour. Today, we&#39;re FIXME" />


<meta property="og:title" content="DynamoDB crash course: part 2 – data model">
<meta property="og:site_name" content="death and gravity">
<meta property="og:type" content="article">
<meta property="og:url" content="https://death.andgravity.com/dynamodb-model">
<meta property="og:description" content="This is part one of a series covering core DynamoDB concepts and patterns, all the way up to single-table design; the goal is to get you to understand idiomatic usage and trade-offs in under an hour. Today, we&#39;re FIXME">



<script>
/* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
function set_vh() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}
/* we do it once, now, *and* on every resize */
set_vh();
window.addEventListener('resize', set_vh);
</script>





<div class="main container grid-lg">


<header>
<nav>
<ul class="breadcrumb">

<li class="breadcrumb-item">
    <a href="/">death and gravity</a>
</li>

</ul>
</nav>

<h1 class="heading-noindex">DynamoDB crash course: part 2 – data model</h1>

<p class="text-gray text-nowrap">



<small>
<span class="tooltip" data-tooltip="published on 2025-12-19">December 2025</span>
∙ 12 minute read
∙
</small><span class="share-icons">
<a
    class="share-icon pycoders"
    href="https://pycoders.com/submissions"
    target="_blank"
>PyCoder's Weekly</a>
<a
    class="share-icon hacker-news"
    href="https://news.ycombinator.%63%6f%6d/submitlink?u=https%3A//death.andgravity.com/dynamodb-model&t=DynamoDB%20crash%20course%3A%20part%202%20%E2%80%93%20data%20model"
>HN</a>
<a
    class="share-icon bluesky"
    href="https://bsky.%61%70%70/intent/compose?text=DynamoDB%20crash%20course%3A%20part%202%20%E2%80%93%20data%20model%20https%3A//death.andgravity.com/dynamodb-model"
>Bluesky</a>
<!--
<a
    class="share-icon reddit"
    href="https://www.reddit.%63%6f%6d/%73%75%62%6d%69%74?url=https%3A//death.andgravity.com/dynamodb-model&title=DynamoDB%20crash%20course%3A%20part%202%20%E2%80%93%20data%20model"
>Reddit</a>
-->
<a
    class="share-icon linkedin"
    href="https://www.linkedin.%63%6f%6d/sharing/share-offsite/?url=https%3A//death.andgravity.com/dynamodb-model"
>linkedin</a>
<a
    class="share-icon twitter"
    href="https://twitter.%63%6f%6d/%73%68%61%72%65?text=DynamoDB%20crash%20course%3A%20part%202%20%E2%80%93%20data%20model&url=https%3A//death.andgravity.com/dynamodb-model&via=_andgravity"
>Twitter</a>
</span>


</p>






</header>


<main class="content columns">
<div class="column col-sm-12 col-md-10 col-8">

<p>This is part two of a series
covering core <strong>DynamoDB</strong> concepts and patterns,
from the data model and features all the way up to <strong>single-table design</strong>.</p>
<p>The goal is to get you
to understand what <strong>idiomatic usage</strong> looks like and
what the <strong>trade-offs</strong> are
in under an hour,
providing entry points to detailed documentation.</p>
<p>FIXME:
(Don't get me wrong, the AWS documentation is comprehensive,
but can be quite complex,
and DynamoDB being a relatively low level product
with lots of features added over the years
doesn't really help with that.)</p>
<p>In the last article, we looked at</p>
<p>Today, we're looking at FIXME</p>
<details class="toc">
<summary>Contents</summary>
<ul>
<li><a href="#core-components">Core components</a>
<ul>
<li><a href="#api-model-tables-items-attributes">API model: tables, items, attributes</a></li>
<li><a href="#logical-model-hash-table-of-b-trees">Logical model: hash table of B‍-‍trees</a></li>
<li><a href="#physical-model-partitions">Physical model: partitions</a></li>
</ul>
</li>
<li><a href="#limits">Limits</a>
<ul>
<li><a href="#partition-throughput">Partition throughput</a></li>
<li><a href="#item-size">Item size</a></li>
<li><a href="#page-size">Page size</a></li>
</ul>
</li>
<li><a href="#indexes">Indexes</a>
<ul>
<li><a href="#global-secondary-indexes">Global secondary indexes</a></li>
<li><a href="#local-secondary-indexes">Local secondary indexes</a></li>
</ul>
</li>
<li><a href="#features">Features</a>
<ul>
<li><a href="#eventual-consistency">Eventual consistency</a></li>
<li><a href="#conditional-writes">Conditional writes</a></li>
<li><a href="#transactions">Transactions</a></li>
<li><a href="#batch-operations">Batch operations</a></li>
<li><a href="#streams">Streams</a></li>
</ul>
</li>
</ul>
</details>
<h2 id="core-components">Core components<span class="headerlink">&nbsp;<a href="#core-components" title="permalink">#</a></span></h2>
<p>According to the <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html">documentation</a>,
the core components of DynamoDB are tables, items, and attributes.
This is accurate in the sense of <strong>what you can act on</strong> through the API,
but can be deceptively simple,
and leaves out two other equally important aspects:
<strong>what you can do with it</strong> (the <em>logical model</em>)
and <strong>how it scales</strong> (the <em>physical model</em>).</p>
<p>Let's put it all together, starting from the top.</p>
<figure class="figure">

<svg xmlns='http://www.w3.org/2000/svg' style='font-size:initial;' class="pikchr" viewBox="0 0 655.2 371.098" data-pikchr-date="20260102012653">
<path d="M3.6,329.76L651.6,329.76A1.44 1.44 0 0 0 653.04 328.32L653.04,3.6A1.44 1.44 0 0 0 651.6 2.16L3.6,2.16A1.44 1.44 0 0 0 2.16 3.6L2.16,328.32A1.44 1.44 0 0 0 3.6 329.76Z"  style="fill:rgb(230,230,250);stroke-width:2.16;stroke:rgb(102,51,153);" />
<path d="M18,315.36L487.44,315.36A1.44 1.44 0 0 0 488.88 313.92L488.88,39.6A1.44 1.44 0 0 0 487.44 38.16L18,38.16A1.44 1.44 0 0 0 16.56 39.6L16.56,313.92A1.44 1.44 0 0 0 18 315.36Z"  style="fill:rgb(255,228,225);stroke-width:1.4472;stroke:rgb(255,0,0);stroke-dasharray:4.32,4.32;" />
<path d="M32.4,300.96L323.28,300.96A1.44 1.44 0 0 0 324.72 299.52L324.72,97.2A1.44 1.44 0 0 0 323.28 95.76L32.4,95.76A1.44 1.44 0 0 0 30.96 97.2L30.96,299.52A1.44 1.44 0 0 0 32.4 300.96Z"  style="fill:rgb(230,230,250);stroke-width:2.16;stroke:rgb(102,51,153);" />
<path d="M46.8,286.56L159.12,286.56A1.44 1.44 0 0 0 160.56 285.12L160.56,162A1.44 1.44 0 0 0 159.12 160.56L46.8,160.56A1.44 1.44 0 0 0 45.36 162L45.36,285.12A1.44 1.44 0 0 0 46.8 286.56Z"  style="fill:rgb(230,230,250);stroke-width:2.16;stroke:rgb(102,51,153);" />
<path d="M61.2,221.76L144.72,221.76A1.44 1.44 0 0 0 146.16 220.32L146.16,198A1.44 1.44 0 0 0 144.72 196.56L61.2,196.56A1.44 1.44 0 0 0 59.76 198L59.76,220.32A1.44 1.44 0 0 0 61.2 221.76Z"  style="fill:rgb(255,255,255);stroke-width:0;stroke:rgb(30,144,255);" />
<text x="102.96" y="209.16" text-anchor="middle" fill="rgb(30,144,255)" dominant-baseline="central">attribute</text>
<path d="M61.2,246.96L144.72,246.96A1.44 1.44 0 0 0 146.16 245.52L146.16,223.2A1.44 1.44 0 0 0 144.72 221.76L61.2,221.76A1.44 1.44 0 0 0 59.76 223.2L59.76,245.52A1.44 1.44 0 0 0 61.2 246.96Z"  style="fill:rgb(255,255,255);stroke-width:0;stroke:rgb(30,144,255);" />
<text x="102.96" y="234.36" text-anchor="middle" fill="rgb(30,144,255)" dominant-baseline="central">attribute</text>
<path d="M61.2,272.16L144.72,272.16A1.44 1.44 0 0 0 146.16 270.72L146.16,248.4A1.44 1.44 0 0 0 144.72 246.96L61.2,246.96A1.44 1.44 0 0 0 59.76 248.4L59.76,270.72A1.44 1.44 0 0 0 61.2 272.16Z"  style="fill:rgb(255,255,255);stroke-width:0;stroke:rgb(30,144,255);" />
<text x="102.96" y="259.56" text-anchor="middle" font-weight="bold" fill="rgb(30,144,255)" dominant-baseline="central">···</text>
<text x="51.12" y="175.68" text-anchor="start" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">item</text>
<path d="M176.4,286.56L259.92,286.56A1.44 1.44 0 0 0 261.36 285.12L261.36,162A1.44 1.44 0 0 0 259.92 160.56L176.4,160.56A1.44 1.44 0 0 0 174.96 162L174.96,285.12A1.44 1.44 0 0 0 176.4 286.56Z"  style="fill:rgb(230,230,250);stroke-width:2.16;stroke:rgb(102,51,153);" />
<text x="218.16" y="223.56" text-anchor="middle" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">···</text>
<text x="180.72" y="175.68" text-anchor="start" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">item</text>
<text x="293.04" y="223.56" text-anchor="middle" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">···</text>
<text x="36.72" y="110.88" text-anchor="start" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">collection (B-tree)</text>
<path d="M340.56,300.96L424.08,300.96A1.44 1.44 0 0 0 425.52 299.52L425.52,97.2A1.44 1.44 0 0 0 424.08 95.76L340.56,95.76A1.44 1.44 0 0 0 339.12 97.2L339.12,299.52A1.44 1.44 0 0 0 340.56 300.96Z"  style="fill:rgb(230,230,250);stroke-width:2.16;stroke:rgb(102,51,153);" />
<text x="382.32" y="198.36" text-anchor="middle" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">···</text>
<text x="344.88" y="110.88" text-anchor="start" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">collection</text>
<text x="457.2" y="198.36" text-anchor="middle" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">···</text>
<text x="22.32" y="53.28" text-anchor="start" fill="rgb(255,0,0)" dominant-baseline="central">partition</text>
<path d="M504.72,315.36L588.24,315.36A1.44 1.44 0 0 0 589.68 313.92L589.68,39.6A1.44 1.44 0 0 0 588.24 38.16L504.72,38.16A1.44 1.44 0 0 0 503.28 39.6L503.28,313.92A1.44 1.44 0 0 0 504.72 315.36Z"  style="fill:rgb(255,228,225);stroke-width:1.4472;stroke:rgb(255,0,0);stroke-dasharray:4.32,4.32;" />
<text x="546.48" y="176.76" text-anchor="middle" font-weight="bold" fill="rgb(255,0,0)" dominant-baseline="central">···</text>
<text x="509.04" y="53.28" text-anchor="start" fill="rgb(255,0,0)" dominant-baseline="central">partition</text>
<text x="621.36" y="176.76" text-anchor="middle" font-weight="bold" fill="rgb(255,0,0)" dominant-baseline="central">···</text>
<text x="7.92" y="17.28" text-anchor="start" font-weight="bold" fill="rgb(102,51,153)" dominant-baseline="central">table (hash table)</text>
<polygon points="218.16,160.56 215.266,152.842 221.054,152.842" style="fill:rgb(102,51,153)"/>
<path d="M218.16,156.701L218.16,146.16"  style="fill:none;stroke-width:1.4472;stroke:rgb(102,51,153);" />
<text x="218.16" y="133.56" text-anchor="middle" fill="rgb(102,51,153)" dominant-baseline="central">sort key</text>
<polygon points="102.96,160.56 100.066,152.842 105.854,152.842" style="fill:rgb(102,51,153)"/>
<path d="M102.96,156.701L102.96,146.16"  style="fill:none;stroke-width:1.4472;stroke:rgb(102,51,153);" />
<text x="102.96" y="133.56" text-anchor="middle" fill="rgb(102,51,153)" dominant-baseline="central">sort key</text>
<text x="160.56" y="133.56" text-anchor="middle" fill="rgb(102,51,153)" dominant-baseline="central">&lt;</text>
<polygon points="177.84,95.76 174.946,88.0416 180.734,88.0416" style="fill:rgb(102,51,153)"/>
<path d="M177.84,91.9008L177.84,81.36"  style="fill:none;stroke-width:1.4472;stroke:rgb(102,51,153);" />
<text x="177.84" y="68.76" text-anchor="middle" fill="rgb(102,51,153)" dominant-baseline="central">partition key</text>
<polygon points="382.32,95.76 379.426,88.0416 385.214,88.0416" style="fill:rgb(102,51,153)"/>
<path d="M382.32,91.9008L382.32,81.36"  style="fill:none;stroke-width:1.4472;stroke:rgb(102,51,153);" />
<text x="382.32" y="68.76" text-anchor="middle" fill="rgb(102,51,153)" dominant-baseline="central">partition key</text>
<path d="M4.02177,368.938L87.5418,368.938A1.44 1.44 0 0 0 88.9818 367.498L88.9818,345.178A1.44 1.44 0 0 0 87.5418 343.738L4.02177,343.738A1.44 1.44 0 0 0 2.58177 345.178L2.58177,367.498A1.44 1.44 0 0 0 4.02177 368.938Z"  style="fill:rgb(230,230,250);stroke-width:2.16;stroke:rgb(102,51,153);" />
<text x="45.7818" y="356.338" text-anchor="middle" fill="rgb(102,51,153)" font-size="80%" dominant-baseline="central">logical</text>
<path d="M97.6218,368.938L181.142,368.938A1.44 1.44 0 0 0 182.582 367.498L182.582,345.178A1.44 1.44 0 0 0 181.142 343.738L97.6218,343.738A1.44 1.44 0 0 0 96.1818 345.178L96.1818,367.498A1.44 1.44 0 0 0 97.6218 368.938Z"  style="fill:rgb(255,228,225);stroke-width:1.4472;stroke:rgb(255,0,0);stroke-dasharray:4.32,4.32;" />
<text x="139.382" y="356.338" text-anchor="middle" fill="rgb(255,0,0)" font-size="80%" dominant-baseline="central">physical only</text>
<path d="M191.222,368.938L274.742,368.938A1.44 1.44 0 0 0 276.182 367.498L276.182,345.178A1.44 1.44 0 0 0 274.742 343.738L191.222,343.738A1.44 1.44 0 0 0 189.782 345.178L189.782,367.498A1.44 1.44 0 0 0 191.222 368.938Z"  style="fill:rgb(255,255,255);stroke-width:0;stroke:rgb(30,144,255);" />
<text x="232.982" y="356.338" text-anchor="middle" fill="rgb(30,144,255)" font-size="80%" dominant-baseline="central">API only</text>
<text x="162.298" y="217.109" text-anchor="middle" fill="rgb(255,228,225)" font-size="64%" transform="rotate(90 162.298,223.56)" dominant-baseline="central">death.andgravity.com</text>
</svg>


</figure>

<h3 id="api-model-tables-items-attributes">API model: tables, items, attributes<span class="headerlink">&nbsp;<a href="#api-model-tables-items-attributes" title="permalink">#</a></span></h3>
<p>As far as the API is concerned,
&quot;a <strong>table</strong> is a collection of <strong>items</strong>,
and each item is a collection of <strong>attributes</strong>&quot;.<sup class="footnote-ref" id="fnref-1"><a href="#fn-1">1</a></sup></p>
<p>An item is uniquely identified by two attributes,
the <strong>partition key</strong> and the <strong>sort key</strong>,<sup class="footnote-ref" id="fnref-2"><a href="#fn-2">2</a></sup>
which together compose its <strong>primary key</strong>.<sup class="footnote-ref" id="fnref-3"><a href="#fn-3">3</a></sup>
A group of items with the same partition key value
is called an <strong>item collection</strong>,<sup class="footnote-ref" id="fnref-4"><a href="#fn-4">4</a></sup>
but this is more of a logical grouping,
and does not exist as a distinct entity in the API.</p>
<p>An attribute is a named data element,
with its value
either a scalar (number, string, binary, boolean, null),
a set of scalars,
or a document (a list or map of possibly nested attributes, similar to JSON).</p>
<p>There are no limits on table size or number of items,
nor on those of an item collection.
Items do have a <a class="anchor" href="#item-size">size limit</a> of 400 KB / item,
which indirectly limits attribute size.</p>
<p>As we've seen <a class="internal" href="/dynamodb#python-mockup">in the previous article</a>,
the core DynamoDB data operations are:</p>
<ul>
<li><code>PutItem</code>, <code>GetItem</code>, <code>UpdateItem</code>, <code>DeleteItem</code></li>
<li><code>Query</code> items with the same partition key, sorted by sort key,
and optionally narrowed down to a specific a range of sort keys</li>
<li><code>Scan</code> all the items in the table, possibly in parallel</li>
</ul>
<p>Besides whole items,
the API allows getting and updating specific attributes,
as well as filtering query and scan results by expressions using them.</p>
<!-- see also
https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html
https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html
-->

<h3 id="logical-model-hash-table-of-b-trees">Logical model: hash table of B‍-‍trees<span class="headerlink">&nbsp;<a href="#logical-model-hash-table-of-b-trees" title="permalink">#</a></span></h3>
<p>The operations above may seem arbitrarily restrictive
– for example, why can't I query items by sort key alone?
It might make more sense to think about it like this:</p>
<p>Conceptually,
a DynamoDB table is <strong>a <a class="external" href="https://en.wikipedia.org/wiki/Hash_table">hash table</a> of <a class="external" href="https://en.wikipedia.org/wiki/B-tree">B‍-‍trees</a></strong>,
with partition keys being hash table keys,
and sort keys being B‍-‍tree keys
(making <em>item collections</em> B‍-‍trees).
The hash table allows efficient <em>find collection by partition key</em> operations;
within each collection,
the B‍-‍tree keeps the items sorted,
and allows efficient <em>find item by sort key</em>
and <em>find items by sort key range</em> operations.</p>
<p>As a consequence,
<strong>any access not based on partition and sort key is expensive</strong>,
since instead of taking advantage of the underlying data structure,
you have to go through <em>all the items</em> in the table to find anything
(aka a <em>full table scan</em>),
and at the scales you'd use DynamoDB at,
this can mean billions of items.<sup class="footnote-ref" id="fnref-5"><a href="#fn-5">5</a></sup></p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p><small>(from <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#:~:text=another%20example%20table%20named%20Music">here</a>)</small>
Take a <em>Music</em> table where items correspond to songs,
with <em>Artist</em> as primary key and <em>Song</em> as sort key:</p>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># table Music (partition key: Artist, sort key: Song)</span>
<span class="nt">1000mods</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Claws</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Album</span><span class="p">:</span><span class="w"> </span><span class="nv">Vultures</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Vidage</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Year</span><span class="p">:</span><span class="w"> </span><span class="nv">2011</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">Kyuss</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Space Cadet</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
<p>You can efficiently:</p>
<ul>
<li>query songs by artist (sorted by song title)</li>
<li>get the song by artist and song title</li>
</ul>
<p>...and that's it, anything else requires a full table scan.</p>
</section>
<p>To a first approximation,
this is also a decent model of how DynamoDB scales
–
you could imagine that each collection has its own dedicated computer,
which in theory would account for the unlimited number of collections.</p>
<h3 id="physical-model-partitions">Physical model: partitions<span class="headerlink">&nbsp;<a href="#physical-model-partitions" title="permalink">#</a></span></h3>
<p>Of course, there are <em>not</em> infinitely many computers,
and that would be wildly inefficient anyway.
Instead, collections are packed together
into a smaller number of <strong>partitions</strong>, each a few gigabytes in size.
To figure out which partition an item should go on,
DynamoDB hashes its <em>partition key</em>
(also called a <em>hash key</em>, for obvious reasons).</p>
<p>This is similar to hash table buckets,<sup class="footnote-ref" id="fnref-6"><a href="#fn-6">6</a></sup>
except there's one more level of indirection –
instead of mapping to a single number,
each partition maps to a range of numbers,
which allows splitting a partition into two new ones
by splitting its range.<sup class="footnote-ref" id="fnref-7"><a href="#fn-7">7</a></sup>
Furthermore, an item collection
(that is, items with the same partition key)
can be split on multiple partitions too
by using the sort key.</p>
<p>And <em>that</em> is how the scaling magic happens:</p>
<ul>
<li>When you increase provisioned capacity,
partitions are split as needed.</li>
<li>If a partition or collection becomes too big,
it gets split.</li>
<li>If the <em>throughput</em> to a partition or collection
is high enough for long enough,
it also gets split,<sup class="footnote-ref" id="fnref-8"><a href="#fn-8">8</a></sup>
possibly with a bias towards keys with higher utilization.</li>
</ul>
<p>Partition management is handled entirely by DynamoDB
and is transparent to the user,
but it doesn't happen instantly –
it takes several minutes to allocate new partitions and shuffle things around.</p>
<p>Since partitions are backed by real computers,
they do have a <a class="anchor" href="#partition-throughput">throughput limit</a>.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey">Core components # Primary key</a></li>
<li><small>(unofficial)</small> <a class="external" href="https://www.alexdebrie.com/posts/dynamodb-partitions">Everything you need to know about DynamoDB Partitions</a></li>
</ul>
</section>
<!-- see also

https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.Partitions.html
https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/burst-adaptive-capacity.html

https://aws.amazon.com/blogs/database/part-1-scaling-dynamodb-how-partitions-hot-keys-and-split-for-heat-impact-performance/
https://aws.amazon.com/blogs/database/part-2-scaling-dynamodb-how-partitions-hot-keys-and-split-for-heat-impact-performance/
https://aws.amazon.com/blogs/database/part-3-scaling-dynamodb-how-partitions-hot-keys-and-split-for-heat-impact-performance/

-->

<!-- TODO: make this an aside or a bonus

Depending on how you structure your data,
a DynamoDB table can correspond to either a single table or a whole database
in a relational database system.

Partitions are somewhat analogous to [shards],
but unlike with most relational databases,
partitions are built *into* the database,
rather than *on top* of it.

A DynamoDB item usually corresponds to a row in a relational database system.

A DynamoDB attribute corresponds to a field in a relational database system.

[shards]: https://en.wikipedia.org/wiki/Shard_(database_architecture)

-->

<h2 id="limits">Limits<span class="headerlink">&nbsp;<a href="#limits" title="permalink">#</a></span></h2>
<p>Part of DynamoDB's appeal is that
it <strong>scales &quot;infinitely&quot;</strong> for specific dimensions:
there are no limits on table size or number of items.
However, there are some hard, non-adjustable limits
you will have to take into account when designing your application.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/CheatSheet.html#CheatSheet.ServiceBasics">Cheat sheet # Service quota basics</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ServiceQuotas.html">Quotas</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Constraints.html">Constraints</a></li>
<li><small>(unofficial)</small> <a class="external" href="https://www.alexdebrie.com/posts/dynamodb-limits/">The Three DynamoDB Limits You Need to Know</a></li>
</ul>
</section>
<!--
TODO/IDEA: cheatsheet table a la big o cheatsheet
(one for table / partition / item )
(one for crud / batch / query/scan / transactions)

like so

| | read (ec) | read (sc) | write |
|-|-|-|-|
| units/s | 3,000 | 3,000 | 1,000 |
| unit size | 4 KB/unit | 4 KB/unit | 1 KB/unit |
| cost | 0.5 unit | 1 unit | 1 unit |
| total | 24 MB/s | 12 MB/s | 1 MB/s |

```
throughput = units/s * unit size * cost
```

-->

<h3 id="partition-throughput">Partition throughput<span class="headerlink">&nbsp;<a href="#partition-throughput" title="permalink">#</a></span></h3>
<p>The most important limit is that
on partition throughput (aka <em>capacity</em>) –
how much data DynamoDB can read from or write
to a <a class="anchor" href="#physical-model-partitions">partition</a>
in a given amount of time:<sup class="footnote-ref" id="fnref-9"><a href="#fn-9">9</a></sup></p>
<ul>
<li><strong>1 MB/s for writes</strong></li>
<li><strong>24 MB/s for reads</strong>, <a class="anchor" href="#eventual-consistency">eventually consistent</a></li>
<li>12 MB/s for reads, strongly consistent</li>
</ul>
<p>Throughput measures
<strong>whole items DynamoDB has to access</strong>,
not the data that goes through the API.
While you can touch single attributes and filter query results,
the consumed capacity is always that
of the <em>whole</em> items DynamoDB had to read or write.<sup class="footnote-ref" id="fnref-10"><a href="#fn-10">10</a></sup></p>
<p>Once you reach the limit,
the operation is throttled,
and you can try again later,
ideally with exponential backoff
(the AWS SDK usually takes care of this for you).</p>
<p>The best way to avoid throttling is
to <strong>distribute the load uniformly across partitions</strong>
by using a <strong>high-cardinality partition key</strong>.<sup class="footnote-ref" id="fnref-11"><a href="#fn-11">11</a></sup>
Uneven key distribution can create <em>hot partitions</em>
that suffer from persistent throttling.</p>
<!-- TODO: should this be a footnote? -->

<p>Nowadays, this is less of a problem.
For long-term imbalances,
<a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/burst-adaptive-capacity.html#isolate-frequent-access-items">partition splitting</a>
should rebalance things over time;
you &quot;might&quot; even end up with a single popular item per partition.
For short-term ones like traffic spikes,
<a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/burst-adaptive-capacity.html#burst-capacity">burst</a> and <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/burst-adaptive-capacity.html#adaptive-capacity">adaptive capacity</a>
will, <em>on a best effort basis</em>,
&quot;borrow&quot; capacity above the table limit
and between partitions.
However,
AWS is very non-committal
about their behavior,
and there's nothing you can do
besides increasing traffic gradually,
so <strong>good partition key design</strong> remains key.</p>
<p>Of note, while the throughput is fixed,
the other dimensions are not;
this means that you have a trade-off between
<em>how often you access items</em>,
the <em>number of items</em>, and <em>item size</em>;
for example, you can split items into smaller ones
based on how attributes are accessed, aka <em><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/data-modeling-blocks.html#data-modeling-blocks-vertical-partitioning">vertical partitioning</a></em>.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.Partitions.html">Partitions and data distribution</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/read-write-operations.html">Read and write operations</a> (capacity unit consumption)</li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html">Partition key design</a><ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-uniform-load.html">Distributing workloads</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-sharding.html">Write sharding</a></li>
</ul>
</li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-sort-keys.html">Sort key design</a></li>
<li><small>(blog)</small> <a class="external" href="https://aws.amazon.com/blogs/database/choosing-the-right-dynamodb-partition-key/">Choosing the Right DynamoDB Partition Key</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/data-modeling-blocks.html#data-modeling-blocks-vertical-partitioning">Data modeling building blocks # Vertical partitioning building block</a></li>
</ul>
 <!-- https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/data-modeling-blocks.html#data-modeling-blocks-write-sharding -->

</section>
<h3 id="item-size">Item size<span class="headerlink">&nbsp;<a href="#item-size" title="permalink">#</a></span></h3>
<p>Second, <strong>the maximum item size is 400 KB</strong>,
which ought to be enough for anybody.
You can work around this limit either by <strong>splitting items into parts</strong>,
or by <strong>putting the data somewhere else</strong> entirely, like S3,
and keeping only a reference in DynamoDB.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Constraints.html#limits-items">Constraints # Items</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-use-s3-too.html">Large items</a></li>
</ul>
</section>
<h3 id="page-size">Page size<span class="headerlink">&nbsp;<a href="#page-size" title="permalink">#</a></span></h3>
<p>Finally,
<strong>the maximum response size for query and scan operations is 1 MB</strong>
(a <em>page</em>).
You can continue from the end of the previous page
by passing the <code>LastEvaluatedKey</code> response element to subsequent calls,
which is essentially
<a class="internal" href="/query-builder-why#intermission-scrolling-window-queries">keyset pagination</a>.
One consequence of this is that,
throughput limit aside,
there's an implicit limit
on how fast you can query the items in a collection,
since the calls are sequentiall.<sup class="footnote-ref" id="fnref-12"><a href="#fn-12">12</a></sup></p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Constraints.html#limits-api">Constraints # API-specific constraints</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.Pagination.html">Paginating query results</a></li>
</ul>
</section>
<h2 id="indexes">Indexes<span class="headerlink">&nbsp;<a href="#indexes" title="permalink">#</a></span></h2>
<p>As discussed in the <a class="anchor" href="#logical-model-hash-table-of-b-trees">logical model</a>,
access not based on primary key is very inefficient.</p>
<p>Secondary indexes allow queries and scans that use <strong>alternative primary keys</strong>,
ones composed of different attributes than that of the base table.
Unlike tables,
index sort keys do not have to be unique for a given partition key.
An item that is missing one of the index primary key attributes
will not appear in the index.</p>
<p>Changes to the table are automatically propagated to any secondary indexes.
Aside from the index and table primary key attributes,
an index can include copies of other attributes
(aka <em><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html#GSI.Projections">attribute projection</a></em>),
which allows the index to answer queries alone,
without extra reads to the base table.<sup class="footnote-ref" id="fnref-13"><a href="#fn-13">13</a></sup></p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.SecondaryIndexes">Core components # Secondary indexes</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SecondaryIndexes.html">Working with indexes</a></li>
</ul>
</section>
<h3 id="global-secondary-indexes">Global secondary indexes<span class="headerlink">&nbsp;<a href="#global-secondary-indexes" title="permalink">#</a></span></h3>
<p>A global secondary index allows using
<strong>different partition <em>and</em> sort key attributes</strong>.</p>
<p>Conceptually,
a global secondary index is <strong>just a table</strong>:
it has its own <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html#GSI.ThroughputConsiderations">separate capacity</a>,
no limits on size or number of items,
and the same <a class="anchor" href="#partition-throughput">partition throughput</a> limits apply.</p>
<p>Despite <abbr title="Global Secondary Index">GSI</abbr>s being updated <a class="anchor" href="#eventual-consistency">asynchronously</a>,
an index without enough capacity to process the updates
will cause <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/gsi-throttling.html">write throttling</a>.
To retrieve attributes not in the index,
you have to get them yourself from the table
(<a class="anchor" href="#batch-operations">batch operations</a> can speed this up).</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p><small>(from <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#:~:text=query%20the%20data%20by%20Genre%20and%20Album">here</a>)</small>
Continuing with the music example,
a <abbr title="Global Secondary Index">GSI</abbr> with <em>Genre</em> and <em>Album</em> as partition and sort keys
would allow you to <em>also</em> efficiently:</p>
<ul>
<li>query songs by genre (and, with additional processing, albums by genre)</li>
<li>query songs by genre and album
(but, since two albums can have the same genre and title,
you might want to group by artist in application code)</li>
</ul>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># table Music (partition key: Artist, sort key: Song)</span>
<span class="nt">Kyuss</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Demon Cleaner</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Album</span><span class="p">:</span><span class="w"> </span><span class="nv">Welcome To Sky Valley</span><span class="p p-Indicator">,</span><span class="nt"> Genre</span><span class="p">:</span><span class="w"> </span><span class="nv">Rock</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Space Cadet</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Album</span><span class="p">:</span><span class="w"> </span><span class="nv">Welcome To Sky Valley</span><span class="p p-Indicator">,</span><span class="nt"> Genre</span><span class="p">:</span><span class="w"> </span><span class="nv">Rock</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">1000mods</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Claws</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Genre</span><span class="p">:</span><span class="w"> </span><span class="nv">Rock</span><span class="w"> </span><span class="p p-Indicator">}</span><span class="w">  </span><span class="c1"># has no Album!</span>
<span class="w">  </span><span class="nt">Vidage</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Album</span><span class="p">:</span><span class="w"> </span><span class="nv">Super Van Vacation</span><span class="p p-Indicator">,</span><span class="nt"> Genre</span><span class="p">:</span><span class="w"> </span><span class="nv">Rock</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">Solar Fields</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Air Song</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Album</span><span class="p">:</span><span class="w"> </span><span class="nv">Leaving Home</span><span class="p p-Indicator">,</span><span class="nt"> Genre</span><span class="p">:</span><span class="w"> </span><span class="nv">Electronic</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># GSI Genres (partition key: Genre, sort key: Album)</span>
<span class="nt">Rock</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Super Van Vacation</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Artist</span><span class="p">:</span><span class="w"> </span><span class="nv">1000mods</span><span class="p p-Indicator">,</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Vidage</span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Welcome To Sky Valley</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Artist</span><span class="p">:</span><span class="w"> </span><span class="nv">Kyuss</span><span class="p p-Indicator">,</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Space Cadet</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Welcome To Sky Valley</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Artist</span><span class="p">:</span><span class="w"> </span><span class="nv">Kyuss</span><span class="p p-Indicator">,</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Demon Cleaner</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">Electronic</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Leaving Home</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Artist</span><span class="p">:</span><span class="w"> </span><span class="nv">Solar Fields</span><span class="p p-Indicator">,</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Air Song</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
</section>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html">Global secondary indexes</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-indexes.html">Best practices for secondary indexes</a></li>
</ul>
</section>
<h3 id="local-secondary-indexes">Local secondary indexes<span class="headerlink">&nbsp;<a href="#local-secondary-indexes" title="permalink">#</a></span></h3>
<p>A local secondary index allows using a <strong>different sort key attribute</strong>.</p>
<p><abbr title="Local Secondary Index">LSI</abbr> data is stored together with partition data
(the index is <em>local</em> to the partition),
so besides the table B‍-‍tree,
each collection has one B‍-‍tree per <abbr title="Local Secondary Index">LSI</abbr>.</p>
<p>This allows strongly consistent reads
and fetching non-projected attributes,
but also <strong>limits collection size to 10 GB</strong>
and <strong>collection throughput to the <a class="anchor" href="#partition-throughput">partition limit</a></strong>,
since it prevents further partition splitting
(as each sort key would split the items in a different way).</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p>A <abbr title="Local Secondary Index">LSI</abbr> with <em>Year</em> as sort key
would allow you to <em>also</em> efficiently:</p>
<ul>
<li>query songs by artist, in chronological order</li>
<li>query songs by artist and year</li>
</ul>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># table Music (partition key: Artist, sort key: Song)</span>
<span class="nt">1000mods</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Claws</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Year</span><span class="p">:</span><span class="w"> </span><span class="nv">2014</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Road To Burn</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Year</span><span class="p">:</span><span class="w"> </span><span class="nv">2011</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Vidage</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Year</span><span class="p">:</span><span class="w"> </span><span class="nv">2011</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">Solar Fields</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Sombrero</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Year</span><span class="p">:</span><span class="w"> </span><span class="nv">2011</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># table Music (partition key: Artist, LSI sort key: Year)</span>
<span class="nt">1000mods</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">2011</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Vidage</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">2011</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Road To Burn</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">2014</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Claws</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">Solar Fields</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">2011</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Song</span><span class="p">:</span><span class="w"> </span><span class="nv">Sombrero</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
</section>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LSI.html">Local secondary indexes</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-indexes.html">Best practices for secondary indexes</a></li>
</ul>
</section>
<h2 id="features">Features<span class="headerlink">&nbsp;<a href="#features" title="permalink">#</a></span></h2>
<p>Before we go into how to structure data for efficient use with DynamoDB,
let's look at some of the things you can do with tables
besides simple <abbr title="create, read, update, and delete">CRUD</abbr> operations.</p>
<!-- FIXME -->

<h3 id="eventual-consistency">Eventual consistency<span class="headerlink">&nbsp;<a href="#eventual-consistency" title="permalink">#</a></span></h3>
<p>So, remember I said partitions are backed by real computers?
I didn't say <em>how many</em>.</p>
<p>To allow the high-availability magic to happen,
a partition is backed by <a class="external" href="https://aws.amazon.com/blogs/database/part-2-scaling-dynamodb-how-partitions-hot-keys-and-split-for-heat-impact-performance/#:~:text=spread%20across%20three%20nodes%20for%20redundancy">three nodes</a>
in separate data centers:<sup class="footnote-ref" id="fnref-14"><a href="#fn-14">14</a></sup>
a leader that handles writes
and two asynchronous replicas.</p>
<p>This explains why there are two kinds of reads:</p>
<ul>
<li><strong>strongly consistent</strong> reads go to the leader,
so you always get the latest data</li>
<li><strong>eventually consistent</strong> reads go to <em>any</em> node,
so you may get slightly older data,
but if you repeat the read later,
you will <em><a class="external" href="https://en.wikipedia.org/wiki/Eventual_consistency">eventually</a></em> get the latest data;
because they use all the available nodes,
they are more efficient, and thus cheaper</li>
</ul>
<p>Note that strongly consistent reads
<strong>do not replace synchronization primitives</strong>
like <a class="anchor" href="#conditional-writes">conditional writes</a>
and <a class="anchor" href="#transactions">transactions</a>,
but they can be useful to lower the rate
at which
these operations fail
for highly-contended items.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html">DynamoDB read consistency</a></li>
</ul>
</section>
<h3 id="conditional-writes">Conditional writes<span class="headerlink">&nbsp;<a href="#conditional-writes" title="permalink">#</a></span></h3>
<p>Write operations can specify a <strong>condition expression</strong>
that must be true for the write to happen
(e.g. an attribute has a specific value);
if the expression is false,
the write fails.
Condition expressions can refer only to the item being modified.</p>
<p>Conditional writes are critical for data consistency
and avoiding concurrency <a class="external" href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">bugs</a>,
since they are only the way to run logic server-side,
while the item is being modified.
You can use conditional writes
to build higher level abstractions like
optimistic locking, <!-- TODO: link -->
<a class="external" href="https://github.com/awslabs/amazon-dynamodb-lock-client">distributed locks</a>,
and atomic counters.<sup class="footnote-ref" id="fnref-15"><a href="#fn-15">15</a></sup></p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html#WorkingWithItems.ConditionalUpdate">Working with items # Conditional writes</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.OperatorsAndFunctions.html">Condition and filter expressions</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ConditionExpressions.html#Expressions.ConditionExpressions.ConditionalExamples">Conditional expressions examples</a></li>
<li><small>(unofficial)</small> <a class="external" href="https://www.alexdebrie.com/posts/dynamodb-condition-expressions/">Understanding DynamoDB Condition Expressions</a></li>
</ul>
</section>
<h3 id="transactions">Transactions<span class="headerlink">&nbsp;<a href="#transactions" title="permalink">#</a></span></h3>
<p>Transactions allow performing <strong>multiple writes</strong>
as <strong>a single atomic operation</strong>,
isolated from other operations;
if two operations attempt to change an item at the same time,
one of them fails.
Transactions can target <strong>up to 100 distinct items</strong>
in one or more tables in the same region,
and consume twice as much capacity.</p>
<p>You can use transactions with <a class="anchor" href="#conditional-writes">condition expressions</a>
– if a condition fails for one item,
none of the items are modified;
you can also <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ConditionCheck.html">check an item</a> without modifying it.
Like with single-item writes,
an expression can refer only an individual item
(you can't have a condition about another item in the transaction).</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/transactions.html">Working with transactions</a></li>
</ul>
</section>
<h3 id="batch-operations">Batch operations<span class="headerlink">&nbsp;<a href="#batch-operations" title="permalink">#</a></span></h3>
<p>Batch operations allow you to
<strong>put/delete up to 25 items</strong> or <strong>read up to 100 items</strong>
in a <strong>single request</strong>, up to 16 MB in total,
more efficiently than using single-item operations.
Batch writes don't support updates or condition expressions.</p>
<p>The operations in a batch are independent from one another
– some writes may fail, or only some of the read items may be returned
(e.g. if <a class="anchor" href="#partition-throughput">throughput limits</a> are reached).</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html#WorkingWithItems.BatchOperations">Working with items # Batch operations</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchGetItem.html">BatchGetItem</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html">BatchWriteItem</a></li>
</ul>
</section>
<h3 id="streams">Streams<span class="headerlink">&nbsp;<a href="#streams" title="permalink">#</a></span></h3>
<p>Streams allow you to <a class="external" href="https://en.wikipedia.org/wiki/Change_data_capture">capture</a>
changes to the items in a table in near-real time.
There are two flavors of streams,
<a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html">DynamoDB Streams</a>
and <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/kds.html">Kinesis Data Streams</a>,
each with different features and integrations.</p>
<p>Notable applications of streams are
<a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.Lambda.html">Lambda triggers</a>
(similar to the ones in relational databases,
except they run <em>after</em> the change),
replication to places like S3 or Redshift <a class="external" href="https://docs.aws.amazon.com/firehose/latest/dev/basic-deliver.html">via Firehose</a>,
and automatic <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/data-modeling-blocks.html#data-modeling-blocks-ttl-archival">archival</a>.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.Streams">Core components # DynamoDB Streams</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/streamsmain.html">Working with streams</a></li>
<li><small>(unofficial)</small> <a class="external" href="https://www.alexdebrie.com/bites/dynamodb-streams/">What you should know about DynamoDB Streams</a></li>
</ul>
</section>
<hr />
<p>Anyway, that's it for now.</p>
<p>In the next article, we'll have a closer look at FIXME</p>
<p><strong>Learned something new today?</strong> Share it with others, it really helps! <span class="text-large">
<span class="share-icons">
<a
    class="share-icon pycoders color"
    href="https://pycoders.com/submissions"
    target="_blank"
>PyCoder's Weekly</a>
<a
    class="share-icon hacker-news color"
    href="https://news.ycombinator.%63%6f%6d/submitlink?u=https%3A//death.andgravity.com/dynamodb-model&t=DynamoDB%20crash%20course%3A%20part%202%20%E2%80%93%20data%20model"
>HN</a>
<a
    class="share-icon bluesky color"
    href="https://bsky.%61%70%70/intent/compose?text=DynamoDB%20crash%20course%3A%20part%202%20%E2%80%93%20data%20model%20https%3A//death.andgravity.com/dynamodb-model"
>Bluesky</a>
<!--
<a
    class="share-icon reddit color"
    href="https://www.reddit.%63%6f%6d/%73%75%62%6d%69%74?url=https%3A//death.andgravity.com/dynamodb-model&title=DynamoDB%20crash%20course%3A%20part%202%20%E2%80%93%20data%20model"
>Reddit</a>
-->
<a
    class="share-icon linkedin color"
    href="https://www.linkedin.%63%6f%6d/sharing/share-offsite/?url=https%3A//death.andgravity.com/dynamodb-model"
>linkedin</a>
<a
    class="share-icon twitter color"
    href="https://twitter.%63%6f%6d/%73%68%61%72%65?text=DynamoDB%20crash%20course%3A%20part%202%20%E2%80%93%20data%20model&url=https%3A//death.andgravity.com/dynamodb-model&via=_andgravity"
>Twitter</a>
</span>
</span></p>

<form
    action="https://gmail.us7.list-manage.com/subscribe/post?u=9909b0e978d8d8d941bd3c8dc&amp;id=c61d63d661&SIGNUP=dynamodb-model"
    method="post"
    id="embedded-subscribe-form"
    name="mc-embedded-subscribe-form"
    target="_blank"
    novalidate
    class="panel subscribe-form"
>
    <div class="panel-header text-large">

        Want to know when new articles come out?

    </div>
    <div class="panel-body">

        <p>Drop your email in the box below and I'll send new stuff straight to your inbox!</p>

        <div class="form-group col-6 col-xs-12 col-md-9">
        <input type="text" name="FNAME" id="mce-FNAME"
            class="form-input input-lg"
            placeholder="Your first name"
        >
        </div>

        <div class="form-group col-6 col-xs-12 col-md-9">
        <input type="email" name="EMAIL" id="mce-EMAIL"
            class="form-input input-lg"
            placeholder="Your email address"
        >
        </div>

        <!-- bot prevention-->
        <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_9909b0e978d8d8d941bd3c8dc_c61d63d661" tabindex="-1" value=""></div>

    </div>
    <div class="panel-footer">

        <div class="form-group">
        <input type="submit"  name="subscribe" id="mc-embedded-subscribe"
            class="btn btn-primary btn-lg"
            value="Subscribe"
        >
        </div>

    </div>

</form>
<section class="footnotes">
<ol>
<li id="fn-1"><p>Here, &quot;collection&quot; just means a &quot;group of things&quot;. <a href="#fnref-1" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-2"><p>Ignore the names for now, it'll make sense in a bit. <a href="#fnref-2" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-3"><p>It is also possible to have
a table with only a partition key and no sort key,
but you can think of that like
a degenerate case where the sort key is a constant value,
and thus each partition key can have only one item. <a href="#fnref-3" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-4"><p>Yes, an <em>item collection</em> is different from a &quot;collection of items&quot;.
Don't look at me, I didn't pick the names. ಠ_ಠ <a href="#fnref-4" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-5"><p><a class="anchor" href="#indexes">Indexes</a>, which we'll discuss later,
offer an escape hatch to this. <a href="#fnref-5" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-6"><p>A quick rant on naming.
With a hash table,
you would say &quot;hash table key&quot;,
or maybe even &quot;item key&quot;;
you would <em>not</em> say &quot;bucket key&quot;,
since that's a low level detail,
and also a bucket can have <em>multiple</em> keys.
You know, like in DynamoDB.</p>
<p>THEN WHY IS IT CALLED A PARTITION KEY <!-- ...partition*ing* key, maybe? --> <a href="#fnref-6" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-7"><p>You have to admit that this is a great explanation.
Surely you would expect to find it in the official documentation,
and not burried in a <a class="external" href="https://aws.amazon.com/blogs/database/part-1-scaling-dynamodb-how-partitions-hot-keys-and-split-for-heat-impact-performance/#:~:text=how%20data%20gets%20assigned%20to%20partitions">random blog post</a> published
at least three years
<a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DocumentHistory.html#:~:text=Adaptive%20capacity%20support%20for%20imbalanced%20workload">after the feature actually launched</a>. <a href="#fnref-7" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-8"><p>Assuming the table has enough configured throughput. <a href="#fnref-8" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-9"><p>Converted to normal people units for your convenience.
DynamoDB uses its own <em>capacity units</em>
as a convoluted way of saying that for accounting purposes,
item size is rounded up to 4 KB (1 <abbr title="Read Capacity Units">RCU</abbr>) for reads
and 1 KB (1 <abbr title="Write Capacity Units">WCU</abbr>) for writes.
This is presumably because the size of a capacity unit
<a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DocumentHistory.html#:~:text=4%20KB%20read%20capacity%20unit%20size">can increase</a> over time. <a href="#fnref-9" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-10"><p>Yes, this includes just counting them. <a href="#fnref-10" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-11"><p>If there is no good natural partition key,
you can make one by sharding a low-cardinality attribute, <!-- TODO: link -->
which we'll cover in the next article. <a href="#fnref-11" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-12"><p>You could make it twice as fast by querying from both ends,
but probably no faster,
since for <a class="internal" href="/pwned#binary-skipping">binary search</a>
you'd need to jump in the middle of two sort keys.
Unsurprisingly,
we'll look at a potential solution in the next article. <a href="#fnref-12" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-13"><p>This is the same as a <a class="external" href="https://en.wikipedia.org/wiki/Database_index#Covering_index">covering index</a> in relational databases. <a href="#fnref-13" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-14"><p>Or better said, <em><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html#ddb-intro-resilience">availability zones</a></em>. <a href="#fnref-14" class="footnote"><sup>[return]</sup></a></p></li>
<li id="fn-15"><p>Although you can also use update expressions for <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html#WorkingWithItems.AtomicCounters">atomic counters</a>. <a href="#fnref-15" class="footnote"><sup>[return]</sup></a></p></li>
</ol>
</section>








</div>
</main>


<footer class="footer">
<p class="text-gray">
<a href="/">home</a>
∙ <a href="/_feed/index.xml">feed</a>
∙ <a href="/about">about</a>

∙ © 2021 lemon24



</footer>


</div>