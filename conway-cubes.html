<!doctype html>

<meta name="viewport" content="width=device-width" />


<link rel="stylesheet" href="/_static/spectre.css">
<link rel="stylesheet" href="/_static/pygments.css">
<link rel="stylesheet" href="/_static/style.css">

<link rel="alternate" type="application/atom+xml" title="Atom feed" href="/_feed/index.xml" />




<title>Solving Advent of Code 2020 day 17 by not solving it - death and gravity</title>


<script>
/* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
function set_vh() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}
/* we do it once, now, *and* on every resize */
set_vh();
window.addEventListener('resize', set_vh);
</script>


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4RY2QR580X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', "G-4RY2QR580X");
</script>





<div class="main container grid-lg">

<ul class="breadcrumb">

<li class="breadcrumb-item">
    <a href="/">death and gravity</a>
</li>

</ul>


<div class="content columns">
<div class="column col-sm-12 col-md-10 col-8">

<h1>Solving Advent of Code 2020 day 17 by not solving it</h1>


<p>... in which we <em>will</em> eventually end up solving the <a href="https://adventofcode.com/2020/day/17">day 17</a> problem from Advent of Code 2020, Conway Cubes, but in a very roundabout way (you will see why shortly).</p>
<p>You can read the article without having solved the problem, but to get the most from it, I recommend you try and solve it first, and then follow along as we do it again here.</p>
<p>Along the way, we'll do some pramgatic testing and refactoring, see how to cheat when faced with hard(er) problems, and hopefully write some idiomatic Python.</p>
<section class="toc">
<ul>
<li><a href="#the-problem-with-the-problem">The problem with the problem</a></li>
<li><a href="#parsing-the-input">Parsing the input</a></li>
<li><a href="#the-world">The world</a></li>
<li><a href="#simulation">Simulation</a></li>
<li><a href="#cleaning-up">Cleaning up</a></li>
<li><a href="#going-3d">Going 3D</a></li>
<li><a href="#results">Results</a></li>
<li><a href="#more-results">More results</a></li>
<li><a href="#success">Success</a></li>
</ul>
</section>
<h2 id="the-problem-with-the-problem">The problem with the problem<span class="headerlink"> <a href="#the-problem-with-the-problem" title="permalink">#</a></span></h2>
<ul>
<li>problem looks familiar<ul>
<li>we have a grid of cells that can be either on or off</li>
<li>cells change their state simultaneously, depending on their neighbors</li>
<li>these things are called <a href="https://en.wikipedia.org/wiki/Cellular_automaton">cellular automata</a><ul>
<li>probably the most famous is Conway's <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a></li>
</ul>
</li>
<li>our problem may be a 3D version of that, it is called <em>Conway</em> Cubes</li>
</ul>
</li>
</ul>
<p>spoiler: part 2 goes 4d</p>
<p>from the start, we can notice this may be relatively hard to visualize</p>
<p>in the example output, for 3d we have 5 planes after 3 cycles and for 4d we have 25 planes (5z * 5w) after 2 cycles! understanding what's happening seems in the 4d one seems difficult even assuming the number of planes remains 25 for future iterations</p>
<p>using the more realistic (but still quite conservative) assumptions that:</p>
<ul>
<li>the number of planes does not depend on the input xy size (the real input is 8 cells wide, while the test input only 3)</li>
<li>the number of planes increases linearly with the number of cycles</li>
</ul>
<p>we get, after 6 cycles:</p>
<ul>
<li>for 3d: 1 + (5-1) * 2 = <strong>9</strong></li>
<li>for 4d: 1 + (9-1) * 6 = <strong>49</strong>, or 1 + (25-1) * 3 = <strong>73</strong></li>
</ul>
<p>it seems the normal flow of the problem would be to first implement the 3d version;
then, after seeing the second part of the problem, we'd either do 4d in a similar fashion, or, maybe easier, generalize the 3d version to an arbitrary number of dimensions.</p>
<p>instead of doing that, let's go the opposite way: let's solve for 2d, which is trivial to visualize, and generalize that</p>
<h2 id="parsing-the-input">Parsing the input<span class="headerlink"> <a href="#parsing-the-input" title="permalink">#</a></span></h2>
<p>First, let's parse the input.</p>
<p>We'll transform the input string into a list of lists of integers, where 0 and 1 represent inactive and active cubes, respectively. For the test input, it should look like this: <code>[[0, 1, 0], [0, 0, 1], [1, 1, 1]]</code>.</p>
<p>Using numbers separates content and presentation, but more importantly, allows for nicer code: we can say <code>if active</code> instead of <code>if active == '#'</code> and <code>sum(cubes)</code> instead of <code>sum(active == '#' for active in cubes)</code>.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">TEST_INPUT</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">.#.</span>
<span class="s2">..#</span>
<span class="s2">###</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">CHARACTERS</span> <span class="o">=</span> <span class="s1">&#39;.#&#39;</span>
<span class="n">CHR_TO_NUM</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">CHARACTERS</span><span class="p">)}</span>

<span class="k">def</span> <span class="nf">parse_input</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">[</span><span class="n">CHR_TO_NUM</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">line</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">input</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
    <span class="p">]</span>
</code></pre></div>
</td></tr></table><p>If we're here, let's also write a function to turn that back into a string; we won't bother trying to minimize the output (e.g. not show empty rows/columns), like the example does, since we're never going to look at more than 1 plane per cycle at a time.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>16
17
18
19
20
21
22</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">NUM_TO_CHR</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">CHARACTERS</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">format_2d</span><span class="p">(</span><span class="n">plane</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">NUM_TO_CHR</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">line</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">plane</span>
    <span class="p">)</span>
</code></pre></div>
</td></tr></table><p>Having both functions, we can also write a small round-trip test:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>24</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">assert</span> <span class="n">format_2d</span><span class="p">(</span><span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">))</span> <span class="o">==</span> <span class="n">TEST_INPUT</span>
</code></pre></div>
</td></tr></table><h2 id="the-world">The world<span class="headerlink"> <a href="#the-world" title="permalink">#</a></span></h2>
<p>There are multiple ways of representing the world, but probably the most straightforward is do it in the same way we represented the input, as a nested list of integers.</p>
<p>The problem says the grid is infinite, but since there are no infinite lists in Python, we'll cheat: we'll just make a big-enough world, and check if we reach the edges to know if we need to make it bigger. For now, 8 should be &quot;big enough&quot;.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>27
28
29</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">x_size</span> <span class="o">=</span> <span class="n">y_size</span> <span class="o">=</span> <span class="mi">8</span>

<span class="n">world</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_size</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y_size</span><span class="p">)]</span>
</code></pre></div>
</td></tr></table><p>Note that <code>[[0] * x_size] * y_size</code> won't work, because the outer list
will contain the (same) inner list y_size times.</p>
<p>We'll place the input in the middle of the world, to give it the same amount of space to grow in every direction:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>32
33
34
35
36
37
38
39
40</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="nb">input</span> <span class="o">=</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">)</span>
<span class="n">input_x_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">//</span> <span class="mi">2</span>
<span class="n">input_y_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span>

<span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">active</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
        <span class="n">world</span><span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="n">input_y_offset</span><span class="p">][</span><span class="n">x</span> <span class="o">+</span> <span class="n">input_x_offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">active</span>

<span class="nb">print</span><span class="p">(</span><span class="n">format_2d</span><span class="p">(</span><span class="n">world</span><span class="p">))</span>
</code></pre></div>
</td></tr></table><p>At this point, our script should output this:</p>
<pre class="code code-container"><code>........
........
...#....
....#...
..###...
........
........
........
</code></pre>
<h2 id="simulation">Simulation<span class="headerlink"> <a href="#simulation" title="permalink">#</a></span></h2>
<p>Let's simulate one cycle.</p>
<p>We have to go through each cell, count its neighbors, and change the state of the cells according to the given rule.</p>
<p>The cube state is changing <em>simultaneously</em> for all cubes, so we cannot update the world in place: given two neighboring cubes updated in order, the old state of the first cube will be gone when we get around to updating the second cube, replaced by the new state. To avoid this, we will have two worlds, and always read from the old one and update the new.</p>
<p>We'll put the logic for one simulation cycle in a function, and pass both the old and the new worlds as arguments:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>27</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
</code></pre></div>
</td></tr></table><p>Then, we go through each cell:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>28
29</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>    <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">old</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">active</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
</code></pre></div>
</td></tr></table><p>The cell's neighbors are all the cubes in a 3x3 square centered on the current cube, <em>except</em> the cube itself:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>31
32
33
34
35
36
37
38
39</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>            <span class="n">active_neighbors</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span>
                    <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">j</span>
</code></pre></div>
</td></tr></table><p>We should now be able to get the neighbor's state with <code>old[ny][nx]</code>; however, we have a couple of (literal) edge cases:</p>
<ul>
<li><p>when the current cell has one of the coordinates 0 (the left or top edges); e.g. the first neighbor will be at (-1, -1); due to how list indexing works, that will actually get the bottom right corner; that is not what we want, since the world is supposed to be infinite in every direction, not wrap around</p>
</li>
<li><p>when the current cell has one of the coordinates <code>size - 1</code> (the right or bottom edge); we'll get an IndexError when trying to look at the right/bottom neighbor</p>
</li>
</ul>
<p>In both cases, we want to know if the current cube is active, since it's possible one of the neighbors that's out of bounds should become active.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>41
42
43
44
45
46
47
48
49
50
51</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>                    <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;active on edge: </span><span class="si">{</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">active_neighbors</span> <span class="o">+=</span> <span class="o">=</span> <span class="n">old</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;active on edge: </span><span class="si">{</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
</code></pre></div>
</td></tr></table><section class="admonition note">
<div class="admonition-text">
<p>Here is where representing cubes as 0/1 comes in handy: we can just add the cube state to the active neighbors counter.</p>
</div>
</section>
<p>Having that, we can set the state of the cell in the new world:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>53
54
55
56
57
58</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>            <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
                <span class="n">new_active</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">active_neighbors</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_active</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">active_neighbors</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">new</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_active</span>
</code></pre></div>
</td></tr></table><p>Let's run that 6 times. Instead instead of creating a new world each iteration, we can reuse the old world from the previous iteration, since we don't need it anymore.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>77
78
79
80
81
82
83
84</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">old</span> <span class="o">=</span> <span class="n">world</span>
<span class="n">new</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_size</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y_size</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">simulate</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
    <span class="n">new</span><span class="p">,</span> <span class="n">old</span> <span class="o">=</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;after cycle #</span><span class="si">{</span><span class="n">cycle</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">format_2d</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
</code></pre></div>
</td></tr></table><details>
<summary>This gives us the following output:</summary>
<pre class="code code-container"><code>........
........
...#....
....#...
..###...
........
........
........

after cycle #1
........
........
........
..#.#...
...##...
...#....
........
........

after cycle #2
........
........
........
....#...
..#.#...
...##...
........
........

after cycle #3
........
........
........
...#....
....##..
...##...
........
........

after cycle #4
........
........
........
....#...
.....#..
...###..
........
........

after cycle #5
........
........
........
........
...#.#..
....##..
....#...
........

after cycle #6
........
........
........
........
.....#..
...#.#..
....##..
........
</code></pre>
</details>
<p>A quick visual inspection confirms our simulation is correct.</p>
<p>We can also see that after 4 cycles, the clump of cells is the same one we had initially, but moved 1 cell to bottom-right; so this is, indeed, Conway's Game of Life, and the entity in the test input is a <a href="https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)">glider</a>.</p>
<p>Let's count the number of active cubes, and add a test to make sure we won't break anything later:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code> 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">world</span> <span class="o">=</span> <span class="n">old</span>

<span class="n">active_cubes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">active</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">world</span> <span class="k">for</span> <span class="n">active</span> <span class="ow">in</span> <span class="n">line</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;the result is&quot;</span><span class="p">,</span> <span class="n">active_cubes</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">active_cubes</span> <span class="o">==</span> <span class="mi">5</span>
<span class="k">assert</span> <span class="n">world</span> <span class="o">==</span> <span class="n">parse_input</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">........</span>
<span class="s2">........</span>
<span class="s2">........</span>
<span class="s2">........</span>
<span class="s2">.....#..</span>
<span class="s2">...#.#..</span>
<span class="s2">....##..</span>
<span class="s2">........</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
</code></pre></div>
</td></tr></table><h2 id="cleaning-up">Cleaning up<span class="headerlink"> <a href="#cleaning-up" title="permalink">#</a></span></h2>
<p>Now that our 2d implementation is correct, we can make it more general.</p>
<p>We won't do that straight away, though; to make it easier to call it in multiple ways later on, we'll split the functionality into functions that we can call separately.</p>
<section class="admonition tip">
<div class="admonition-text">
<p>Throughout these changes, our little test suite should keep passing. While writing the script, I used <a href="https://eradman.com/entrproject/">entr</a> to re-run the script whenever I saved it:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash"><span></span><code><span class="nb">echo</span> conway-cubes.py <span class="p">|</span> entr -rc python conway-cubes.py
</code></pre></div>
<p>Your editor may have have a &quot;save and run&quot; function; if it doesn't (or you don't want to use it), <em>entr</em> is an editor-independent way of achieving the same thing.</p>
</div>
</section>
<p>First, let's extract the neighbor-counting logic in a function:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">get_active_neighbors</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">active_neighbors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">j</span>

            <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;active on edge: </span><span class="si">{</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">active_neighbors</span> <span class="o">+=</span> <span class="n">world</span><span class="p">[</span><span class="n">ny</span><span class="p">][</span><span class="n">nx</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;active on edge: </span><span class="si">{</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

    <span class="k">return</span> <span class="n">active_neighbors</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>53
54
55
56
57</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">old</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">active</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">active_neighbors</span> <span class="o">=</span> <span class="n">get_active_neighbors</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="c1"># ...</span>
</code></pre></div>
</td></tr></table><p>Then, the construction of worlds:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>66
67</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">make_world</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>72</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">world</span> <span class="o">=</span> <span class="n">make_world</span><span class="p">(</span><span class="n">x_size</span><span class="p">,</span> <span class="n">y_size</span><span class="p">)</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>87</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">new</span> <span class="o">=</span> <span class="n">make_world</span><span class="p">(</span><span class="n">x_size</span><span class="p">,</span> <span class="n">y_size</span><span class="p">)</span>
</code></pre></div>
</td></tr></table><p>Then, the input copying:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>70
71
72
73
74
75</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">copy_centered_2d</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
    <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">x_offset</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">dst</span><span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="n">y_offset</span><span class="p">][</span><span class="n">x</span> <span class="o">+</span> <span class="n">x_offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>84</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">copy_centered_2d</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">world</span><span class="p">)</span>
</code></pre></div>
</td></tr></table><p>Finally, let's wrap the whole workflow in function, so we can call it multiple times.</p>
<p>Again, to separate logic from presentation, we'll split this into a generator that yields new states, forever; note that it first yields the initial state:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>78
79
80
81
82
83
84
85
86
87
88</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">simulate_forever</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
    <span class="n">old</span> <span class="o">=</span> <span class="n">make_world</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">make_world</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="n">copy_centered_2d</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">old</span><span class="p">)</span>

    <span class="k">yield</span> <span class="n">old</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">simulate</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span>
        <span class="k">yield</span> <span class="n">old</span>
</code></pre></div>
</td></tr></table><p>... and a function that drives it and goes through 6 cycles and prints the worlds; since we want to use it for multiple dimensions, but do not want to implement formatting the world for that, we'll make it optional. Also, since we still want to have our little tests, we'll return the last state of the world and the number of active cubes.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code> 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">format_world</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">worlds</span> <span class="o">=</span> <span class="n">simulate_forever</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">input</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">world</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">worlds</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;after cycle #</span><span class="si">{</span><span class="n">cycle</span><span class="si">}</span><span class="s2">: &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">format_world</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">format_world</span><span class="p">(</span><span class="n">world</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)</span>

    <span class="n">active_cubes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">active</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">world</span> <span class="k">for</span> <span class="n">active</span> <span class="ow">in</span> <span class="n">line</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;the result is&quot;</span><span class="p">,</span> <span class="n">active_cubes</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">world</span><span class="p">,</span> <span class="n">active_cubes</span>


<span class="n">world</span><span class="p">,</span> <span class="n">active_cubes</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">),</span> <span class="n">format_world</span><span class="o">=</span><span class="n">format_2d</span><span class="p">)</span>
</code></pre></div>
</td></tr></table><h2 id="going-3d">Going 3D<span class="headerlink"> <a href="#going-3d" title="permalink">#</a></span></h2>
<p>Let's follow the flow in <code>simulate_forever</code> and start making it work with N dimensions.</p>
<p>First, we'll fix <code>make_world</code>.</p>
<p>Instead of having explicit arguments for the size of each dimension, we'll have a single  argument, a tuple sizes, one for each dimension. Reusing &quot;size&quot; as the name would be confusing, and &quot;sizes&quot; may be as well; &quot;shape&quot;?</p>
<p>To handle the fact that we now have an arbitrary number of dimensions, we could make <code>make_world</code> recursive, but there's a cleaner solution: <code>copy.deepcopy</code>, which makes deep copies of entire object hierarchies (yes, the recursion still exists, but its tucked away).</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>1</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>69
70
71
72
73</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">make_world</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="n">world</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="n">world</span> <span class="o">=</span> <span class="p">[</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">world</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">world</span>
</code></pre></div>
</td></tr></table><p>We'll bubble this change up to <code>run</code>; its <code>size</code> argument will remain an int, but we'll add an <code>dimensions</code> argument, so we can have an n-dimensional &quot;square&quot; world.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>84
85
86
87</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">simulate_forever</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
    <span class="n">old</span> <span class="o">=</span> <span class="n">make_world</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">make_world</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># ...</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>97
98
99</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">format_world</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">worlds</span> <span class="o">=</span> <span class="n">simulate_forever</span><span class="p">((</span><span class="n">size</span><span class="p">,)</span> <span class="o">*</span> <span class="n">dimensions</span><span class="p">,</span> <span class="nb">input</span><span class="p">)</span>
    <span class="c1"># ...</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>114</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">world</span><span class="p">,</span> <span class="n">active_cubes</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">),</span> <span class="n">format_world</span><span class="o">=</span><span class="n">format_2d</span><span class="p">)</span>
</code></pre></div>
</td></tr></table><p>Next, let's handle input copying; for 2d, the destination was the world; for more than that, we need to find the middle plane, and use that:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>84
85
86
87
88
89
90
91
92
93</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">simulate_forever</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
    <span class="n">old</span> <span class="o">=</span> <span class="n">make_world</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">make_world</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">copy_dst</span> <span class="o">=</span> <span class="n">old</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]):</span>
        <span class="n">copy_dst</span> <span class="o">=</span> <span class="n">copy_dst</span><span class="p">[(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">copy_centered_2d</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">copy_dst</span><span class="p">)</span>

    <span class="c1"># ...</span>
</code></pre></div>
</td></tr></table><p>Continuing with <code>simulate</code>, we need to find a generic version of the nested loop that goes over all the cells. We'll write a version of <code>enumerate</code> that works with nested iterables, which instead of <em>i, value</em> pairs, yields <em>(..., k, j, i), value</em> pairs:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">ndenumerate</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">world</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">dimensions</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">dimensions</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">world</span><span class="p">):</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">i</span><span class="p">,),</span> <span class="n">value</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">world</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">ndenumerate</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">dimensions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">i</span><span class="p">,)</span> <span class="o">+</span> <span class="n">t</span><span class="p">,</span> <span class="n">value</span>
</code></pre></div>
</td></tr></table><section class="admonition note">
<div class="admonition-text">
<p>You may notice we stole the function name <a href="https://numpy.org/doc/stable/reference/generated/numpy.ndenumerate.html">from numpy</a>. Initially it was called <code>coord_enumerate</code> and it generated <em>..., k, j, i, value</em> tuples, but since it does exactly the same thing it's better for it to be familiar.</p>
<p>Unlike with numpy arrays, we have to infer the number of dimensions, since our nested lists don't have an explicit shape. If we ran <code>simulate</code> a lot of times, we may want to calculate it just once, and after that pass it around.</p>
<p>Also unlike the numpy version, our version only works with lists; to make it work with any nested sequences, we could use <code>isinstance(temp, collections.abc.Sequence)</code> instead.</p>
</div>
</section>
<p>We'll leave <code>get_active_neighbors</code> for last; before that, let's make <code>simulate</code> entirely general:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>74
75
76
77
78
79
80
81
82
83
84
85
86</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">coords</span><span class="p">,</span> <span class="n">active</span> <span class="ow">in</span> <span class="n">ndenumerate</span><span class="p">(</span><span class="n">old</span><span class="p">):</span>
        <span class="n">active_neighbors</span> <span class="o">=</span> <span class="n">get_active_neighbors</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="o">*</span><span class="nb">reversed</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
            <span class="n">new_active</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">active_neighbors</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_active</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">active_neighbors</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>

        <span class="n">target</span> <span class="o">=</span> <span class="n">new</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span>
        <span class="n">target</span><span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_active</span>
</code></pre></div>
</td></tr></table><p>Since <code>run</code> also needs to go through all the cubes to count the active ones, let's change it to use <code>ndenumerate</code> as well:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>131</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>    <span class="n">active_cubes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">active</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">active</span> <span class="ow">in</span> <span class="n">ndenumerate</span><span class="p">(</span><span class="n">world</span><span class="p">))</span>
</code></pre></div>
</td></tr></table><p>Finally, let's do <code>get_active_neighbors</code>.</p>
<p>First, we'll flatten the loop that generates neighbor coordinates using <code>itertools.product</code>:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>2</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>31
32
33</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">make_directions</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="n">dimensions</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span> <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">dimensions</span><span class="p">]</span>
</code></pre></div>
</td></tr></table><p><code>get_active_neighbors</code> then becomes:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">get_active_neighbors</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
    <span class="n">active_neighbors</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">offsets</span> <span class="ow">in</span> <span class="n">make_directions</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>

        <span class="n">neighbor_coords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">coord</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="k">for</span> <span class="n">coord</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">offsets</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">coord</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">neighbor_coords</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;active on edge: </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">neighbor</span> <span class="o">=</span> <span class="n">world</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">neighbor_coords</span><span class="p">:</span>
                <span class="n">neighbor</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">active</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;active on edge: </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">active_neighbors</span> <span class="o">+=</span> <span class="n">neighbor</span>

    <span class="k">return</span> <span class="n">active_neighbors</span>
</code></pre></div>
</td></tr></table><p>Let's also fix its call site in <code>simulate</code>:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>84</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code>        <span class="n">active_neighbors</span> <span class="o">=</span> <span class="n">get_active_neighbors</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</code></pre></div>
</td></tr></table><p>And that's it!</p>
<h2 id="results">Results<span class="headerlink"> <a href="#results" title="permalink">#</a></span></h2>
<p>The problem tells us that for the test input, there should be 112 active cubes; let's add a test for that:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>160
161</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">_</span><span class="p">,</span> <span class="n">active_cubes</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">))</span>
<span class="k">assert</span> <span class="n">active_cubes</span> <span class="o">==</span> <span class="mi">112</span>
</code></pre></div>
</td></tr></table><p>And we get:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python Traceback"><span></span><code><span class="x">after cycle #0: ...</span>
<span class="x">after cycle #1: ...</span>
<span class="x">after cycle #2: ...</span>
<span class="x">after cycle #3: ...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;conway-cubes.py&quot;</span>, line <span class="m">161</span>, in <span class="n">&lt;module&gt;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">active_cubes</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">))</span>
  File <span class="nb">&quot;conway-cubes.py&quot;</span>, line <span class="m">131</span>, in <span class="n">run</span>
    <span class="k">for</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">world</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">worlds</span><span class="p">):</span>
  File <span class="nb">&quot;conway-cubes.py&quot;</span>, line <span class="m">123</span>, in <span class="n">simulate_forever</span>
    <span class="n">simulate</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
  File <span class="nb">&quot;conway-cubes.py&quot;</span>, line <span class="m">84</span>, in <span class="n">simulate</span>
    <span class="n">active_neighbors</span> <span class="o">=</span> <span class="n">get_active_neighbors</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
  File <span class="nb">&quot;conway-cubes.py&quot;</span>, line <span class="m">47</span>, in <span class="n">get_active_neighbors</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;active on edge: </span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gr">RuntimeError</span>: <span class="n">active on edge: (2, 3, 0)</span>
</code></pre></div>
<p>Good thing we have those checks. Let's bump the world size to 16. It works:</p>
<pre class="code code-container"><code>after cycle #0: ...
after cycle #1: ...
after cycle #2: ...
after cycle #3: ...
after cycle #4: ...
after cycle #5: ...
after cycle #6: ...
the result is 112
</code></pre>
<p>Time to plug my puzzle input; I assume they're generated randomly, so feel free to use yours instead.</p>
<p>At first I got another &quot;active on edge&quot; error; since the test input already takes about a second to compute for 3d, I'll increase the world size by smaller increments instead of doubling it; I found 20 is enough:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>163
164
165
166
167
168
169
170
171
172
173
174</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">INPUT</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">.##...#.</span>
<span class="s2">.#.###..</span>
<span class="s2">..##.#.#</span>
<span class="s2">##...#.#</span>
<span class="s2">#..#...#</span>
<span class="s2">#..###..</span>
<span class="s2">.##.####</span>
<span class="s2">..#####.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_</span><span class="p">,</span> <span class="n">active_cubes</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">INPUT</span><span class="p">))</span>
</code></pre></div>
</td></tr></table><p>And <code>the result is 386</code>, which unlocks the second part of the problem. Let's add an assert for that as well:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>175</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">assert</span> <span class="n">active_cubes</span> <span class="o">==</span> <span class="mi">386</span>
</code></pre></div>
</td></tr></table><h2 id="more-results">More results<span class="headerlink"> <a href="#more-results" title="permalink">#</a></span></h2>
<p>Moving on to 4d; the problem says the cube count for the test input is 848:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>177
178
179
180</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">_</span><span class="p">,</span> <span class="n">active_cubes</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">))</span>
<span class="k">assert</span> <span class="n">active_cubes</span> <span class="o">==</span> <span class="mi">848</span>

<span class="n">_</span><span class="p">,</span> <span class="n">active_cubes</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">INPUT</span><span class="p">))</span>
</code></pre></div>
</td></tr></table><p>... aaand the first cycle for the test input takes about 10 seconds. Let's add some timings in <code>run</code> before we let this run any further:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>3</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="kn">import</span> <span class="nn">time</span>
</code></pre></div>
</td></tr></table><table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">format_world</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">worlds</span> <span class="o">=</span> <span class="n">simulate_forever</span><span class="p">((</span><span class="n">size</span><span class="p">,)</span> <span class="o">*</span> <span class="n">dimensions</span><span class="p">,</span> <span class="nb">input</span><span class="p">)</span>

    <span class="n">total_time</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">world</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">worlds</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;after cycle #</span><span class="si">{</span><span class="n">cycle</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s): &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">format_world</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">format_world</span><span class="p">(</span><span class="n">world</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)</span>

        <span class="n">total_time</span> <span class="o">+=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>

    <span class="n">active_cubes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">active</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">active</span> <span class="ow">in</span> <span class="n">ndenumerate</span><span class="p">(</span><span class="n">world</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the result is </span><span class="si">{</span><span class="n">active_cubes</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">total_time</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">s)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">world</span><span class="p">,</span> <span class="n">active_cubes</span>
</code></pre></div>
</td></tr></table><p>After 1 minute, we confirm it worked for the test input, and <em>after 2 more minutes</em>, I get the cube count for my input: 2276; it's correct.</p>
<h2 id="success">Success<span class="headerlink"> <a href="#success" title="permalink">#</a></span></h2>
<p>Success?</p>
<p>Success! We did most of our coding for 2d, which is easy to understand and debug, and 3d and 4d worked out of the box. I'm sure there's a lesson here.</p>
<p>Success... but at what cost? TBD: discuss exponential growth</p>
<p>TBD: performance to be continued...</p>



</div>
</div>


<div class="footer">

<p class="text-gray">
© 2021 lemon24
∙ <a href="/_feed/index.xml">feed</a>
∙ <a href="/about">about</a>


</div>


</div>