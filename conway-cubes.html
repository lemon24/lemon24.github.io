<!doctype html>

<meta name="viewport" content="width=device-width" />


<link rel="stylesheet" href="/_static/spectre.css">
<link rel="stylesheet" href="/_static/pygments.css">
<link rel="stylesheet" href="/_static/style.css">

<link rel="alternate" type="application/atom+xml" title="Atom feed" href="/_feed/index.xml" />




<title>Solving Advent of Code 2020 day 17 by not solving it - death and gravity</title>


<script>
/* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
function set_vh() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}
/* we do it once, now, *and* on every resize */
set_vh();
window.addEventListener('resize', set_vh);
</script>





<div class="main container grid-lg">

<ul class="breadcrumb">

<li class="breadcrumb-item">
    <a href="/">death and gravity</a>
</li>

</ul>


<div class="content columns">
<div class="column col-sm-12 col-md-10 col-8">

<h1>Solving Advent of Code 2020 day 17 by not solving it</h1>


<p><a href="https://adventofcode.com/2020/day/17">Advent of Code 2020 day 17</a></p>
<ul>
<li>problem looks familiar<ul>
<li>we have a grid of cells that can be either on or off</li>
<li>cells change their state simultaneously, depending on their neighbors</li>
<li>these things are called <a href="https://en.wikipedia.org/wiki/Cellular_automaton">cellular automata</a><ul>
<li>probably the most famous is Conway's <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a></li>
</ul>
</li>
<li>our problem may be a 3D version of that, it is called <em>Conway</em> Cubes</li>
</ul>
</li>
</ul>
<p>spoiler: part 2 goes 4d</p>
<p>from the start, we can notice this may be relatively hard to visualize</p>
<p>in the example output, for 3d we have 5 planes after 3 cycles and for 4d we have 25 planes (5z * 5w) after 2 cycles! understanding what's happening seems in the 4d one seems difficult even assuming the number of planes remains 25 for future iterations</p>
<p>using the more realistic (but still quite conservative) assumptions that:</p>
<ul>
<li>the number of planes does not depend on the input xy size (the real input is 8 cells wide, while the test input only 3)</li>
<li>the number of planes increases linearly with the number of cycles</li>
</ul>
<p>we get, after 6 cycles:</p>
<ul>
<li>for 3d: 1 + (5-1) * 2 = <strong>9</strong></li>
<li>for 4d: 1 + (9-1) * 6 = <strong>49</strong>, or 1 + (25-1) * 3 = <strong>73</strong></li>
</ul>
<p>it seems the normal flow of the problem would be to first implement the 3d version;
then, after seeing the second part of the problem, we'd either do 4d in a similar fashion, or, maybe easier, generalize the 3d version to an arbitrary number of dimensions.</p>
<p>instead of doing that, let's go the opposite way: let's solve for 2d, which is trivial to visualize, and generalize that</p>
<section class="toc">
<ul>
<li><a href="#parsing-the-input">parsing the input</a></li>
<li><a href="#the-world">the world</a></li>
</ul>
</section>
<h2 id="parsing-the-input">parsing the input<span class="headerlink"> <a href="#parsing-the-input" title="permalink">#</a></span></h2>
<p>First, let's parse the input.</p>
<p>We'll transform the input string into a list of lists of integers, where 0 and 1 represent inactive and active cubes, respectively. For the test input, it should look like this: <code>[[0, 1, 0], [0, 0, 1], [1, 1, 1]]</code>.</p>
<p>Using numbers separates content and presentation, but more importantly, allows for nicer code: we can say <code>if active</code> instead of <code>if active == '#'</code> and <code>sum(cubes)</code> instead of <code>sum(active == '#' for active in cubes)</code>.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">TEST_INPUT</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">.#.</span>
<span class="s2">..#</span>
<span class="s2">###</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">CHARACTERS</span> <span class="o">=</span> <span class="s1">&#39;.#&#39;</span>
<span class="n">CHR_TO_NUM</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">CHARACTERS</span><span class="p">)}</span>

<span class="k">def</span> <span class="nf">parse_input</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">[</span><span class="n">CHR_TO_NUM</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">line</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">input</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
    <span class="p">]</span>
</code></pre></div>
</td></tr></table><p>If we're here, let's also write a function to turn that back into a string; we won't bother trying to minimize the output (e.g. not show empty rows/columns), like the example does, since we're never going to look at more than 1 plane per cycle at a time.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>16
17
18
19
20
21
22</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">NUM_TO_CHR</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">CHARACTERS</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">format_2d</span><span class="p">(</span><span class="n">plane</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">NUM_TO_CHR</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">line</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">plane</span>
    <span class="p">)</span>
</code></pre></div>
</td></tr></table><p>Having both functions, we can also write a small round-trip test:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>24</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="k">assert</span> <span class="n">format_2d</span><span class="p">(</span><span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">))</span> <span class="o">==</span> <span class="n">TEST_INPUT</span>
</code></pre></div>
</td></tr></table><h2 id="the-world">the world<span class="headerlink"> <a href="#the-world" title="permalink">#</a></span></h2>
<p>There are multiple ways of representing the world, but probably the most straightforward is do it in the same way we represented the input, as a nested list of integers.</p>
<p>The problem says the grid is infinite, but since there are no infinite lists in Python, we'll cheat: we'll just make a big-enough world, and check if we reach the edges to know if we need to make it bigger. For now, 8 should be &quot;big enough&quot;.</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>27
28
29</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="n">x_size</span> <span class="o">=</span> <span class="n">y_size</span> <span class="o">=</span> <span class="mi">8</span>

<span class="n">world</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_size</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y_size</span><span class="p">)]</span>
</code></pre></div>
</td></tr></table><p>Note that <code>[[0] * x_size] * y_size</code> won't work, because the outer list
will contain the (same) inner list y_size times.</p>
<p>We'll place the input in the middle of the world, to give it the same amount of space to grow in every direction:</p>
<table class="highlighttable code-container"><tr><td class="linenos"><div class="linenodiv"><pre class="code"><code>32
33
34
35
36
37
38
39
40</code></pre></div></td><td class="code"><div class="highlight"><pre class="code" data-lang="Python"><span></span><code><span class="nb">input</span> <span class="o">=</span> <span class="n">parse_input</span><span class="p">(</span><span class="n">TEST_INPUT</span><span class="p">)</span>
<span class="n">input_x_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">//</span> <span class="mi">2</span>
<span class="n">input_y_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span>

<span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">active</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
        <span class="n">world</span><span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="n">input_y_offset</span><span class="p">][</span><span class="n">x</span> <span class="o">+</span> <span class="n">input_x_offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">active</span>

<span class="nb">print</span><span class="p">(</span><span class="n">format_2d</span><span class="p">(</span><span class="n">world</span><span class="p">))</span>
</code></pre></div>
</td></tr></table><p>At this point, our script should output this:</p>
<pre class="code code-container"><code>........
........
...#....
....#...
..###...
........
........
........
</code></pre>



</div>
</div>


<div class="footer">

<p class="text-gray">
© 2021 lemon24 
∙ <a href="/_feed/index.xml">feed</a>
∙ <a href="/about">about</a>


</div>


</div>