<!doctype html>

<meta name="viewport" content="width=device-width" />


<link rel="stylesheet" href="/_static/spectre.css">
<link rel="stylesheet" href="/_static/pygments.css">
<link rel="stylesheet" href="/_static/style.css">

<link rel="alternate" type="application/atom+xml" title="Atom feed" href="/_feed/index.xml" />






<title>untitled - death and gravity</title>


<script>
/* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
function set_vh() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}
/* we do it once, now, *and* on every resize */
set_vh();
window.addEventListener('resize', set_vh);
</script>


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4RY2QR580X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', "G-4RY2QR580X");
</script>



<div class="main container grid-lg">


<header>
<nav>
<ul class="breadcrumb">

<li class="breadcrumb-item">
    <a href="/">death and gravity</a>
</li>

</ul>
</nav>

<h1>untitled</h1>

<p class="text-gray"><small>

</small></p>

</header>


<main class="content columns">
<div class="column col-sm-12 col-md-10 col-8">

<ul>
<li>in which we see how to calculate a deterministic hash for Python data objects<ul>
<li>stable across interpreter implementations and versions</li>
</ul>
</li>
</ul>
<details>
<summary>Contents</summary>
<section class="toc">
<ul>
<li><a href="#the-real-world-problem">The real-world problem</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#problem-we-need-a-stable-hash-function">Problem: we need a stable hash function</a>
<ul>
<li><a href="#hash">hash()</a></li>
<li><a href="#hashlib">hashlib</a></li>
</ul>
</li>
<li><a href="#problem-we-need-a-deterministic-way-of-serializing-objects">Problem: we need a deterministic way of serializing objects</a>
<ul>
<li><a href="#pickle">pickle</a></li>
<li><a href="#str-and-repr">str() and repr()</a></li>
<li><a href="#json">json</a></li>
</ul>
</li>
<li><a href="#problem-ignore-empty-value">problem: ignore empty value</a></li>
<li><a href="#problem-skip-fields">problem: skip fields</a></li>
<li><a href="#conclusion">conclusion</a></li>
</ul>
</section>
</details>
<h2 id="the-real-world-problem">The real-world problem<span class="headerlink"> <a href="#the-real-world-problem" title="permalink">#</a></span></h2>
<p>Let's say you have a <a href="https://github.com/lemon24/reader">feed reader library</a>;
one of its main features is to retrieve and store <a href="https://en.wikipedia.org/wiki/Web_feed">web feeds</a>
(Atom, RSS, and so on).</p>
<p>Entries (articles) usually have an <em>updated</em> date,
indicating the last time the entry was modified in a significant way.
An entry is updated only if its <em>updated</em> date in the feed
is newer than the one we have stored for it.</p>
<p>However, you notice the content of some entries changes
without <em>updated</em> changing,
so you decide to update entries whenever the content changes,
regardless of <em>updated</em>.</p>
<p>After the feed is retrieved,
entries are converted to data objects like these
(the real ones have <a href="https://github.com/lemon24/reader/blob/d2aaf418f8c4d45a97cabaa7eb76498239d0503b/src/reader/_types.py#L97-L114">more attributes</a>, though):</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Content</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">language</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Entry</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">updated</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">content</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Content</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
</code></pre></div>
<p>A naive approach is to getting the stored entry data
and compare it with the feed version,
but that's pretty inefficient.</p>
<p>The better solution is to use a hash function
– a way to map data of arbitrary size (the message)
to a fixed-size chunk of data (the hash value),
such that:</p>
<ul>
<li>it is quick to compute the hash value for any given message</li>
<li>the same message always results in the same hash</li>
<li>it is extremely unlikely two slightly different messages have the same hash</li>
</ul>
<p>Then, instead of getting the full entry data,
we just get its (previously computed) hash,
and compare it with the hash of the feed version.</p>
<section class="admonition note">
<div class="admonition-text">
<p><a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">Cryptographic hash functions</a> have more properties,
 but we don't need them.</p>
</div>
</section>
<h2 id="requirements">Requirements<span class="headerlink"> <a href="#requirements" title="permalink">#</a></span></h2>
<p>Looking at out use case, we need a hash function that:</p>
<ol>
<li>supports (almost) arbitrary data objects;
 in our case, the various built-in types, datetimes,
 and dataclass instances should be enough</li>
<li>is safe; passing an unsupported object should be an error</li>
<li>is stable across interpreter versions and implementations,
 operating systems, and host machines</li>
<li>ignores &quot;empty&quot; values, to allow adding new fields without the hash changing</li>
<li>can skip some of the fields (I actually realized this is needed much later)</li>
</ol>
<h2 id="problem-we-need-a-stable-hash-function">Problem: we need a stable hash function<span class="headerlink"> <a href="#problem-we-need-a-stable-hash-function" title="permalink">#</a></span></h2>
<h3 id="hash">hash()<span class="headerlink"> <a href="#hash" title="permalink">#</a></span></h3>
<p>An easy solution seems to be the built-in <a href="https://docs.python.org/3/library/functions.html#hash">hash()</a> function,
which returns the integer hash of an object.
However, it has a couple of issues:</p>
<p>By default, the hashes of str and bytes objects
are randomized for security reasons (<a href="https://docs.python.org/3/reference/datamodel.html#object.__hash__">details</a>, second note),
so they're not predictable between Python processes:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>python3 -c <span class="s1">&#39;print(hash(&quot;abc&quot;))&#39;</span>
<span class="go">-4743820898567001518</span>
<span class="gp">$ </span>python3 -c <span class="s1">&#39;print(hash(&quot;abc&quot;))&#39;</span>
<span class="go">-6699381079787346150</span>
</code></pre></div>
<p>Also, hash() only supports <a href="https://docs.python.org/3/glossary.html#term-hashable">hashable</a> objects;
this means no lists, dicts, or non-<a href="https://docs.python.org/3/library/dataclasses.html#frozen-instances">frozen</a> dataclasses.
For my specific use case, this wasn't actually a problem, but
it already puts huge constraints on how arbitrary the data objects can be.</p>
<h3 id="hashlib">hashlib<span class="headerlink"> <a href="#hashlib" title="permalink">#</a></span></h3>
<p><a href="https://docs.python.org/3/library/hashlib.html">hashlib</a> contains many different secure hash algorithms,
which are by definition deterministic.</p>
<p>But it has one big problem – it only takes bytes:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="go">&#39;900150983cd24fb0d6963f7d28e17f72&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">Unicode-objects must be encoded before hashing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object supporting the buffer API required</span>
</code></pre></div>
<p>This is something we can work with, though: it changes our problem
from &quot;we need a stable hash function&quot;
to &quot;we need a deterministic way of serializing objects to bytes&quot;.</p>
<h2 id="problem-we-need-a-deterministic-way-of-serializing-objects">Problem: we need a deterministic way of serializing objects<span class="headerlink"> <a href="#problem-we-need-a-deterministic-way-of-serializing-objects" title="permalink">#</a></span></h2>
<h3 id="pickle">pickle<span class="headerlink"> <a href="#pickle" title="permalink">#</a></span></h3>
<p><a href="https://docs.python.org/3/library/pickle.html">pickle</a> can turn most Python objects into bytes.</p>
<p>It does have multiple protocols,
and the default one can change with the Python version;
but we can select one and stick with it –
version 4 was added in Python 3.4, and seems good enough.</p>
<p>Again, the easy solution is deceiving, since it seems to work:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span><span class="k">function</span> pickle <span class="o">{</span>
<span class="gp">$</span><span class="m">1</span> &lt;&lt;EOD
<span class="go">import pickle</span>
<span class="go">from datetime import datetime</span>
<span class="go">print(pickle.dumps($3, protocol=$2))</span>
<span class="go">EOD</span>
<span class="go">}</span>
<span class="gp">$ </span>pickle python3.6 <span class="m">4</span> <span class="s1">&#39;[1, &quot;abc&quot;]&#39;</span> <span class="p">|</span> md5sum
<span class="go">02fa88b9fea0912efe731ed56906b251  -</span>
<span class="gp">$ </span>pickle python3.7 <span class="m">4</span> <span class="s1">&#39;[1, &quot;abc&quot;]&#39;</span> <span class="p">|</span> md5sum
<span class="go">02fa88b9fea0912efe731ed56906b251  -</span>
<span class="gp">$ </span>pickle python3.8 <span class="m">4</span> <span class="s1">&#39;[1, &quot;abc&quot;]&#39;</span> <span class="p">|</span> md5sum
<span class="go">02fa88b9fea0912efe731ed56906b251  -</span>
<span class="gp">$ </span>pickle pypy3.6 <span class="m">4</span> <span class="s1">&#39;[1, &quot;abc&quot;]&#39;</span> <span class="p">|</span> md5sum
<span class="go">02fa88b9fea0912efe731ed56906b251  -</span>
</code></pre></div>
<p>... until it doesn't:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>pickle python3.6 <span class="m">4</span> <span class="s1">&#39;datetime(1, 1, 1)&#39;</span> <span class="p">|</span> md5sum
<span class="go">9c4423b791578d865d8fbeb070a1b934  -</span>
<span class="gp">$ </span>pickle pypy3.6 <span class="m">4</span> <span class="s1">&#39;datetime(1, 1, 1)&#39;</span> <span class="p">|</span> md5sum
<span class="go">3c7c834cb2f1cf4aba8be5c326bb9ddd  -</span>
</code></pre></div>
<p>Version 0 isn't stable either, but in a different way:</p>
<div class="highlight code-container"><pre class="code" data-lang="Bash Session"><span></span><code><span class="gp">$ </span>pickle python3.6 <span class="m">0</span> <span class="s1">&#39;datetime(1, 1, 1)&#39;</span> <span class="p">|</span> md5sum
<span class="go">01acd91b95556a09f5ff9b7495e120da  -</span>
<span class="gp">$ </span>pickle pypy3.6 <span class="m">0</span> <span class="s1">&#39;datetime(1, 1, 1)&#39;</span> <span class="p">|</span> md5sum
<span class="go">01acd91b95556a09f5ff9b7495e120da  -</span>
<span class="gp">$ </span>pickle python3.7 <span class="m">0</span> <span class="s1">&#39;datetime(1, 1, 1)&#39;</span> <span class="p">|</span> md5sum
<span class="go">a6c815eca494dbf716cd4a7e5556d779  -</span>
</code></pre></div>
<p>Version 3 does <em>seem</em> to work fine across all of the above,
on both macOS and Linux (I also tested it with more complicated data).
But what's to say it'll remain that way?</p>
<p>In fairness, <em>this is not an issue with pickle</em> –
it guarantees you'll get the same object back after unpickling,
not that you'll get the same binary stream after pickling.</p>
<p>And it's easy to explain why: pickles are actually <em>programs</em>.
Some relevant comments from <a href="https://github.com/python/cpython/blob/3.9/Lib/pickletools.py">pickletools</a>:</p>
<blockquote>
<p>&quot;A pickle&quot; is a program for a virtual pickle machine (PM, but more accurately
called an unpickling machine). It's a sequence of opcodes, interpreted by the
PM, building an arbitrarily complex Python object.</p>
</blockquote>
<blockquote>
<p>Historically, many enhancements
have been made to the pickle protocol in order to do a better (faster,
and/or more compact) job on
[builtin scalar and container types, like ints and tuples].</p>
</blockquote>
<blockquote>
<p>As explained below [for compatibility],
pickle opcodes never go away, not even when better ways to do a thing
get invented. The repertoire of the PM just keeps growing over time.</p>
</blockquote>
<p>This means there can be multiple pickles
that unpickle to the same object<sup class="footnote-ref" id="fnref-1"><a href="#fn-1">1</a></sup>,
even within the bounds of a specific protocol.</p>
<h3 id="str-and-repr">str() and repr()<span class="headerlink"> <a href="#str-and-repr" title="permalink">#</a></span></h3>
<p><a href="https://docs.python.org/3/library/functions.html#func-str">str()</a> and <a href="https://docs.python.org/3/library/functions.html#repr">repr()</a> might seem like valid solutions,
but neither of them are.</p>
<p>First, they're not stable, and not guaranteed
to have all the information we may care about:</p>
<blockquote>
<p><code>str(object)</code> returns <code>object.__str__()</code>, which is the &quot;informal&quot; or nicely printable string representation of object. [...] If object does not have a <code>__str__()</code> method, then <code>str()</code> falls back to returning <code>repr(object)</code>.</p>
</blockquote>
<blockquote>
<p>For many types, [<code>repr()</code>] makes an attempt to return a string that would yield an object with the same value when passed to <code>eval()</code>, otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object.</p>
</blockquote>
<p>More importantly, they're not safe – <em>all</em> Python objects have them,
even some that we would not want to serialize at all:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">Content</span><span class="p">(</span><span class="nb">object</span><span class="p">())</span>
<span class="go">Content(value=&lt;object object at 0x7f993cd5ff40&gt;, language=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Content</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Content(value=&lt;function &lt;lambda&gt; at 0x7f993e96ec10&gt;, language=None)</span>
</code></pre></div>
<h3 id="json">json<span class="headerlink"> <a href="#json" title="permalink">#</a></span></h3>
<p><a href="https://docs.python.org/3/library/json.html">json</a> might be what we need;
even the pickle documentation seems to recommend it,
although for <a href="https://docs.python.org/3/library/pickle.html#comparison-with-json">different reasons</a>.</p>
<p>Compared to the previous solutions, json has the opposite problem:
it <a href="https://docs.python.org/3/library/json.html#json.JSONEncoder">only supports</a> dicts (with string/number keys only),
lists, strings, and a few others.</p>
<p>But we can turn this to our advantage
by converting <em>only</em> the stuff we want to support to a JSON-encodable form,
and the json module makes this really easy; let's start with datetimes:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">json_default</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">datetime</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">thing</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(</span><span class="n">timespec</span><span class="o">=</span><span class="s1">&#39;microseconds&#39;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;object of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> not serializable&quot;</span><span class="p">)</span>
</code></pre></div>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="n">json_default</span><span class="p">)</span>
<span class="go">&#39;&quot;0001-01-01T00:00:00.000000&quot;&#39;</span>
</code></pre></div>
<p>Dataclasses aren't much harder to add, thanks to <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict">asdict()</a>,
which converts dataclass instances to a dict,
recursing into other dataclasses, dicts, lists and tuples:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">json_default</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">asdict</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">datetime</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">thing</span><span class="o">.</span><span class="n">isoformat</span><span class="p">(</span><span class="n">timespec</span><span class="o">=</span><span class="s1">&#39;microseconds&#39;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;object of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> not serializable&quot;</span><span class="p">)</span>
</code></pre></div>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">Entry</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">content</span><span class="o">=</span><span class="p">[</span><span class="n">Content</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">)]),</span> <span class="n">default</span><span class="o">=</span><span class="n">json_default</span><span class="p">)</span>
<span class="go">&#39;{&quot;id&quot;: &quot;id&quot;, &quot;updated&quot;: &quot;0001-01-01T00:00:00.000000&quot;, &quot;content&quot;: [{&quot;value&quot;: &quot;value&quot;, &quot;language&quot;: null}]}&#39;</span>
</code></pre></div>
<p>You may notice the dataclass type does not appear in the result,
which for our use case is actually fine:
dataclasses <code>One(value=1)</code> and <code>Two(value=1)</code> will both get converted
to the dict <code>{'value': 1}</code>, resulting in the same hash.
If wanted them to be different, we could include the type name:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="s1">&#39;__type&#39;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="o">**</span><span class="n">asdict</span><span class="p">(</span><span class="n">thing</span><span class="p">)}</span>
<span class="p">{</span><span class="s1">&#39;__type&#39;</span><span class="p">:</span> <span class="s1">&#39;Content&#39;</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;language&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
</code></pre></div>
<p>To ensure the output remains stable across Python versions,
we'll force all of the <a href="https://docs.python.org/3/library/json.html#json.dumps">dumps()</a> default arguments to known values,
and require it to sort the keys in dicts:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">json_dumps</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span>
        <span class="n">thing</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">json_default</span><span class="p">,</span>
        <span class="n">ensure_ascii</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sort_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">indent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">separators</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">),</span>
    <span class="p">)</span>
</code></pre></div>
<p>One more wrapper to hash the serialized value, and we're done:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span> <span class="nf">get_hash</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">json_dumps</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
</code></pre></div>
<div class="highlight code-container"><pre class="code" data-lang="Python console session"><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="n">get_hash</span><span class="p">(</span><span class="n">Entry</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">content</span><span class="o">=</span><span class="p">[</span><span class="n">Content</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">)]))</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;78b4b8120af5f832b7ecfc34db1fe02b&#39;</span>
</code></pre></div>
<h2 id="problem-ignore-empty-value">problem: ignore empty value<span class="headerlink"> <a href="#problem-ignore-empty-value" title="permalink">#</a></span></h2>
<p>explain why this is needed, with code example: Class vs NewClass</p>
<p>solution: dataclasses.asdict(dict_factory=...)</p>
<p>code example, get_hash(class) == get_hash(newclass)</p>
<h2 id="problem-skip-fields">problem: skip fields<span class="headerlink"> <a href="#problem-skip-fields" title="permalink">#</a></span></h2>
<p>could do it in json_default</p>
<p>problem: would be ok for our use case, but would not work for nested dataclasses; if possible, the code should be as generic as possible</p>
<p>solution: have classes tell us if they want something skipped</p>
<p>can't do it with asdict():  recursive and we need to intercept and check
the <code>_hash_exclude_</code> of nested dataclasses; we implement a non-recursive version of asdict();
this way, json.dumps() does the recursion instead of asdict()</p>
<p>code example</p>
<h2 id="conclusion">conclusion<span class="headerlink"> <a href="#conclusion" title="permalink">#</a></span></h2>
<p>link to the real deal</p>
<p>decent tradeoff between generality and safety</p>
<p>something else?</p>
<p>maybe mention future proofing with version</p>
<!--

https://stackoverflow.com/questions/5583907/is-the-builtin-hash-method-of-python2-6-stable-across-architectures
https://stackoverflow.com/questions/27522626/hash-function-in-python-3-3-returns-different-results-between-sessions
https://stackoverflow.com/questions/46768213/how-to-hash-a-class-or-function-definition
https://stackoverflow.com/questions/6550660/python-are-hash-values-for-built-in-numeric-types-strings-standardised
https://stackoverflow.com/questions/45015180/deterministic-recursive-hashing-in-python
https://stackoverflow.com/questions/5884066/hashing-a-dictionary/8714242#8714242
https://softwareengineering.stackexchange.com/questions/405243/how-to-perform-consistent-hashing-on-any-python-object-that-works-with-hash
https://github.com/cloudpipe/cloudpickle/issues/120 Making cloudpickle produce "consistent/deterministic" results.

-->
<section class="footnotes">
<ol>
<li id="fn-1"><p>I found this idea somewhere on Stack Overflow,
but I can't seem to find that specific post again. <a href="#fnref-1" class="footnote"><sup>[return]</sup></a></p></li>
</ol>
</section>







</div>
</main>


<footer class="footer">
<p class="text-gray">
<a href="/">home</a>
∙ <a href="/_feed/index.xml">feed</a>
∙ <a href="/about">about</a>

∙ © 2021 lemon24
</footer>


</div>