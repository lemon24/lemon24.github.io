












<!doctype html>

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/_static/spectre.css">
<link rel="stylesheet" href="/_static/pygments.css">
<link rel="stylesheet" href="/_static/style.css">

<link rel="alternate" type="application/atom+xml" title="Atom feed" href="/_feed/index.xml" />

<link rel="icon" href="/_static/xo-system-icon.svg">
<link rel="apple-touch-icon" href="/_static/xo-system-icon.svg">







<title>DynamoDB crash course: part 3 – design patterns - death and gravity</title>



<meta property="og:title" content="DynamoDB crash course: part 3 – design patterns">
<meta property="og:site_name" content="death and gravity">
<meta property="og:type" content="article">
<meta property="og:url" content="https://death.andgravity.com/dynamodb-patterns">




<script>
/* https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */
function set_vh() {
    let vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}
/* we do it once, now, *and* on every resize */
set_vh();
window.addEventListener('resize', set_vh);
</script>





<div class="main container grid-lg">


<header>
<nav>
<ul class="breadcrumb">

<li class="breadcrumb-item">
    <a href="/">death and gravity</a>
</li>

</ul>
</nav>

<h1 class="heading-noindex">DynamoDB crash course: part 3 – design patterns</h1>

<p class="text-gray text-nowrap">



<small>
<span class="tooltip" data-tooltip="published on 2025-12-19">December 2025</span>
∙ nine minute read
∙
</small><span class="share-icons">
<a
    class="share-icon pycoders"
    href="https://pycoders.com/submissions"
    target="_blank"
>PyCoder's Weekly</a>
<a
    class="share-icon hacker-news"
    href="https://news.ycombinator.%63%6f%6d/submitlink?u=https%3A//death.andgravity.com/dynamodb-patterns&t=DynamoDB%20crash%20course%3A%20part%203%20%E2%80%93%20design%20patterns"
>HN</a>
<a
    class="share-icon bluesky"
    href="https://bsky.%61%70%70/intent/compose?text=DynamoDB%20crash%20course%3A%20part%203%20%E2%80%93%20design%20patterns%20https%3A//death.andgravity.com/dynamodb-patterns"
>Bluesky</a>
<!--
<a
    class="share-icon reddit"
    href="https://www.reddit.%63%6f%6d/%73%75%62%6d%69%74?url=https%3A//death.andgravity.com/dynamodb-patterns&title=DynamoDB%20crash%20course%3A%20part%203%20%E2%80%93%20design%20patterns"
>Reddit</a>
-->
<a
    class="share-icon linkedin"
    href="https://www.linkedin.%63%6f%6d/sharing/share-offsite/?url=https%3A//death.andgravity.com/dynamodb-patterns"
>linkedin</a>
<a
    class="share-icon twitter"
    href="https://twitter.%63%6f%6d/%73%68%61%72%65?text=DynamoDB%20crash%20course%3A%20part%203%20%E2%80%93%20design%20patterns&url=https%3A//death.andgravity.com/dynamodb-patterns&via=_andgravity"
>Twitter</a>
</span>


</p>






</header>


<main class="content columns">
<div class="column col-sm-12 col-md-10 col-8">

<details class="toc" open>
<summary>Table of Contents</summary>
<ul>
<li><a href="#composite-keys">Composite keys</a></li>
<li><a href="#single-table-design">Single table design</a></li>
<li><a href="#gsi-overloading">GSI overloading</a></li>
<li><a href="#partition-key-sharding">Partition key sharding</a></li>
<li><a href="#sparse-indexes">Sparse indexes</a></li>
<li><a href="#base-table-indexes">Base-table indexes</a></li>
<li><a href="#optimistic-locking">Optimistic locking</a></li>
</ul>
</details>
<p>To help deal with DynamoDB being as low level as it is
(i.e. to work around its <a class="internal" href="/dynamodb-model#limits">limits</a>,
and perhpas make best use of its <a class="internal" href="/dynamodb-model#features">features</a>),
a number of design patterns have arisen,
documented pretty extensively in the official documentation.</p>
<p>TODO: in this section, I'll go through some of the most important patterns (nonexhaustive)</p>
<p>TODO: individually simple (mostly), but they are most powerful (and hardest to write code for) when used together</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/data-modeling.html">Data modeling</a><ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/data-modeling-schemas.html">Data modeling schemas</a> (worked examples)</li>
</ul>
</li>
</ul>
</section>
<h2 id="composite-keys">Composite keys<span class="headerlink">&nbsp;<a href="#composite-keys" title="permalink">#</a></span></h2>
<p>Composite (aka synthetic) keys are the pattern which underpins most other patterns.</p>
<p>The idea is that <strong>keys don't have to be natural attributes</strong> of your data,
but can instead be <strong>composed of multiple attributes</strong>,
chosen to enable specific <strong>access patterns</strong>.
This, like other patterns, works equally well with table and index keys.</p>
<p>How do you compose attributes?
By string concatenation, of course!
Careful with numeric attributes though,
they need padding to be useful in sort keys.</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p>To sort lexicographically by more than one attribute,
you group them in a sort key, e.g. <code>{Album}#{Song}</code>.</p>
<p>Or, in <a class="anchor" href="#single-table-design">single table design</a>,
you distinguish between item types
by prefixing keys with the type,
e.g. <code>album#{Album}</code>.</p>
<p>Or, in <a class="anchor" href="#partition-key-sharding">partition key sharding</a>,
you spread the load on a GSI partition by splitting one partition key
into multiple ones, e.g. <code>{Genre}#{shard}</code>.</p>
</section>
<p>But denormalization has costs and trade-offs.
For sort key <code>{Album}#{Song}</code>,
should <em>Album</em> and <em>Song</em> also be separate attributes?
If yes,
you need to ensure they never change,
but you can use them in indexes
(e.g. a GSI with <em>Album</em> as primary key).
If no,
the item can't become inconsistent,
but you always need to parse the key.</p>
<p>This was inconvenient enough
that in 2025
they finally added support for <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html#GSI.MultiAttributeKeys">multi-attribute keys</a> to GSIs
(but seeminly not bad enough to also add it to tables).</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/data-modeling-blocks.html#data-modeling-blocks-composite">Data modeling building blocks # Composite sort key</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.DesignPattern.MultiAttributeKeys.html">Multi-attribute keys pattern</a></li>
</ul>
</section>
<h2 id="single-table-design">Single table design<span class="headerlink">&nbsp;<a href="#single-table-design" title="permalink">#</a></span></h2>
<p>AWS <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-general-nosql-design.html">recommends</a> using as few tables as possible:</p>
<blockquote>
<p>As a general rule,
you should maintain as few tables as possible in a DynamoDB application.
[...]
A single table with inverted indexes can usually enable simple queries
to create and retrieve the complex hierarchical data structures
required by your application.</p>
</blockquote>
<p>This culminates in single table design,
where you put <strong>all entities in the same table</strong>,
and distinguish between them based on the key format, usually using a prefix.
With this pattern,
a single DynamoDB table corresponds
to a whole relational database.</p>
<p>Simplest is to have
<strong>all items related to a top-level entity
on the same partition</strong>.
This makes joins with the top entity trivial,
and allows getting different entity types in a single query,
which can be both faster (fewer queries)
and cheaper (small items pack into fewer capacity units).</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p>You could group items related to an <em>Artist</em> on the same partition,
with sort keys like
<code>artist</code>, <code>album#{Album}</code>, and <code>song#{Album}#{Song}</code>.</p>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># table Music (partition key: Artist, sort key: sk)</span>
<span class="nt">Solar Fields</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="s">&#39;album#Leaving</span><span class="nv"> </span><span class="s">Home&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Genre</span><span class="p">:</span><span class="w"> </span><span class="nv">Electronic</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="s">&#39;artist&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Variations</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="w"> </span><span class="nv">Solarfields</span><span class="w"> </span><span class="p p-Indicator">]</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="s">&#39;song#Leaving</span><span class="nv"> </span><span class="s">Home#Air</span><span class="nv"> </span><span class="s">Song&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Duration</span><span class="p">:</span><span class="w"> </span><span class="nv">741</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="s">&#39;song#Leaving</span><span class="nv"> </span><span class="s">Home#Monogram&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Duration</span><span class="p">:</span><span class="w"> </span><span class="nv">944</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
<p>This allows interesting single queries like:</p>
<ul>
<li>get artist details and all their albums</li>
<li>get album details and all the songs on that album</li>
</ul>
</section>
<p>However, it can be useful to put some
<strong>sub-entities on dedicated partitions</strong>,
accepting that joins will have to be done in code
(although this can be an advantage,
since it allows querying multiple partitions in parallel).</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p>In the example above,
a popular artist with lots of songs can lead to:</p>
<ul>
<li>throttling due to <a class="internal" href="/dynamodb-model#partition-throughput">partition throughput</a> limits</li>
<li>slow <em>list songs for artist</em> due to sequential <a class="internal" href="/dynamodb-model#page-size">paginated queries</a></li>
</ul>
<p>Perhaps it's better to put songs in each album on separate partitions:</p>
<ul>
<li>partition key <code>artist#{Artist}</code>, sort key <code>artist</code> or <code>album#{Album}</code></li>
<li>partition key <code>song#{Artist}#{Album}</code>, sort key <code>{Song}</code></li>
</ul>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># table Music (partition key: pk, sort key: sk)</span>
<span class="s">&#39;artist#Solar</span><span class="nv"> </span><span class="s">Fields&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="s">&#39;album#Leaving</span><span class="nv"> </span><span class="s">Home&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Genre</span><span class="p">:</span><span class="w"> </span><span class="nv">Electronic</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="s">&#39;artist&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Variations</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="w"> </span><span class="nv">Solarfields</span><span class="w"> </span><span class="p p-Indicator">]</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="s">&#39;song#Solar</span><span class="nv"> </span><span class="s">Fields#Leaving</span><span class="nv"> </span><span class="s">Home&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="s">&#39;Air</span><span class="nv"> </span><span class="s">Song&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Duration</span><span class="p">:</span><span class="w"> </span><span class="nv">741</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="s">&#39;Monogram&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> Duration</span><span class="p">:</span><span class="w"> </span><span class="nv">944</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
<p>This spreads the load onto multiple partitions,
which should fix throttling.</p>
<p>The downside is that <em>list songs for artist</em>
is now a two-step operation:
first do one query for the albums,
then do one query <em>per album</em> for the songs.
The upside is that the per-album queries can be done in parallel,
which wasn't possible before.</p>
</section>
<p>A consequence of single table design is that
<strong>you need a GSI to list all items of a specific type</strong>
(otherwise, you have to do a full table scan).
Of note, exceeding GSI write limits
will cause <a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/gsi-throttling.html">write throttling</a> of the main table;
in the absence of a natural high-cardinality GSI partition key,
a <a class="anchor" href="#composite-keys">composite key</a> or <a class="anchor" href="#partition-key-sharding">sharding</a> can help.</p>
<p>A final advantage of using a single table is
<strong>better utilization with provisioned mode</strong>:
usage gets averaged across entities and tends to be smoother,
and traffic spikes can share the same spare capacity.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-general-nosql-design.html">NoSQL design</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/data-modeling-foundations.html#data-modeling-foundations-single">Data modeling foundations # Single table design</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-relational-modeling.html#bp-relational-modeling-joins">Relational modeling # JOIN operations</a></li>
<li><small>(blog)</small> <a class="external" href="https://aws.amazon.com/blogs/database/single-table-vs-multi-table-design-in-amazon-dynamodb/">Single-table vs. multi-table design in Amazon DynamoDB</a></li>
<li><small>(unofficial)</small> <a class="external" href="https://www.alexdebrie.com/posts/dynamodb-single-table/">The What, Why, and When of Single-Table Design with DynamoDB</a></li>
</ul>
</section>
<h2 id="gsi-overloading">GSI overloading<span class="headerlink">&nbsp;<a href="#gsi-overloading" title="permalink">#</a></span></h2>
<p>Just like tables
can have more than one type of item,
so can GSIs –
that is,
you can put different things in the GSI partition/sort key attributes,
depending on item type.
This allows indexing more fields than the 20 GSIs per table quota,
and may be cheaper too,
since fewer GSIs can make better use of spare provisioned capacity.</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p>For a table that contains both artist and album items,
a single GSI could be used for entirely different purposes:</p>
<ul>
<li>artist: partition key <code>artist#{Country}</code> – list artists by country</li>
<li>album: partition key <code>album#{Genre}</code> – list albums by genre</li>
</ul>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># table Music (partition key: Artist, sort key: sk)</span>
<span class="nt">2 Bit Pie</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="s">&#39;album#2</span><span class="nv"> </span><span class="s">Pie</span><span class="nv"> </span><span class="s">Island&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> gsi1pk</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;album#Electronic&#39;</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="s">&#39;artist&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> gsi1pk</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;artist#United</span><span class="nv"> </span><span class="s">Kingdom&#39;</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="nt">Ishome</span><span class="p">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="s">&#39;album#Confession&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> gsi1pk</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;album#Electronic&#39;</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="s">&#39;artist&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> gsi1pk</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;artist#Russia&#39;</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
<div class="highlight code-container"><pre class="code" data-lang="YAML"><span></span><code><span class="c1"># GSI GSI1 (partition key: gsi1pk, sort key: Artist)</span>
<span class="s">&#39;artist#United</span><span class="nv"> </span><span class="s">Kingdom&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">2 Bit Pie</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> sk</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;artist&#39;</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="s">&#39;artist#Russia&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">Ishome</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> sk</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;artist&#39;</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="s">&#39;album#Electronic&#39;</span><span class="p p-Indicator">:</span><span class="w"> </span><span class="kt">!btree</span>
<span class="w">  </span><span class="nt">2 Bit Pie</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> sk</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;album#2</span><span class="nv"> </span><span class="s">Pie</span><span class="nv"> </span><span class="s">Island&#39;</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">Ishome</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> sk</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;album#Confession&#39;</span><span class="w"> </span><span class="p p-Indicator">}</span>
</code></pre></div>
</section>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-gsi-overloading.html">GSI overloading</a></li>
</ul>
</section>
<h2 id="partition-key-sharding">Partition key sharding<span class="headerlink">&nbsp;<a href="#partition-key-sharding" title="permalink">#</a></span></h2>
<p>Sometimes, not even a partition key composed of multiple natural attributes
is enough to spread the load evenly across partition;
one way of dealing with this is to put items corresponding
to a natural attribute on multiple partitions.</p>
<p>The question is then, what should the partition key for an item be?
One possibility is to use a <strong>random suffix</strong> from a known range;
this still allows you to list items for a natural attribute
by doing multipe queries, one for each suffix.</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p>For our table of songs,
using the album as part of the partition key may not work,
since not all songs are part of an album these days.
Instead, we could use <code>{Artist}#{randrange(10)}</code> as partition key.
Then, to list all the songs for an artist, we'd do:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">for</span> <span class="n">shard</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">dynamodb</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">artist</span><span class="si">}</span><span class="s2">#</span><span class="si">{</span><span class="n">shard</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">item</span>
</code></pre></div>
<p>Now we can have 10 times as many items
before reaching throughput limits.</p>
</section>
<p>A downside of random suffixes is that you can't get a specific item,
since you don't know what suffix you used for any given item.
An alternative is to <strong>calculate the suffix</strong>
from something that you do know,
like the hash of an attribute modulo N.</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p>Instead of a random number,
we could use <code>{Artist}#{hash(Song) % 10)}</code>.
Then, to get a song by artist and song title:</p>
<div class="highlight code-container"><pre class="code" data-lang="Python"><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">hash</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">sha256</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">digest</span><span class="p">())</span>

<span class="n">shard</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">song_title</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span>
<span class="n">dynamodb</span><span class="o">.</span><span class="n">get_item</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">artist</span><span class="si">}</span><span class="s2">#</span><span class="si">{</span><span class="n">shard</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">song_title</span><span class="p">)</span>
</code></pre></div>
</section>
<p>Sharding may be even more important for GSIs,
where a lot of times you want to list items by a low-cardinality attribute.</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p>Assuming you have dedicated album items,
to list all the albums
you could use a single GSI partition
with partition key <code>albums</code> (literal string)
and sort key <code>{Album}</code>,
but this may overload the partition.</p>
<p>To spread the load,
you could use <code>album#{hash(Album} % 100}</code>
as partition key
if you don't care about them being sorted,
or something like <code>album#{Album[0].lower()}</code>
if you want them sorted alphabetically
(but, careful about
some first letters <a class="external" href="https://en.wikipedia.org/wiki/Letter_frequency#Relative_frequencies_of_the_first_letters_of_a_word_in_English_language">being more popular than others</a>,
and some albums <a class="external" href="https://www.discogs.com/release/10506005--">not starting with a letter at all</a>).</p>
</section>
<p>One other benefit of sharding
is that you can query them in parallel,
which can speed up getting the entire result set.</p>
<hr />
<p>The number of shards is a trade-off –
too many shards means more queries,
too few shards means you might still overload the partitions.</p>
<p>Importantly, <strong>increasing the number of shards is non-trivial</strong>,
so ideally you should avoid it if possible.</p>
<p>One way to do it is
to move to a new index (or just partition key prefix) entirely,
which means you need to backfill existing items in the new index,
and then switch to it.
Alternatively, you could add new shards,
and either keep old items on existing shards
(e.g. by assigning them an &quot;epoch&quot; based on when they were created),
or re-balance them
(although this may not be possible
without downtime / inconsistencies).</p>
<p>Regardless of what you do,
it requires support in application code,
and careful orchestration when making the switch
(for example,
if you expose a <code>LastEvaluatedKey</code>-derived pagination token to users,
you have either temporarily support both,
or accept some downtime).</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-sharding.html">Write sharding</a></li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-indexes-gsi-sharding.html">GSI sharding</a></li>
</ul>
</section>
<h2 id="sparse-indexes">Sparse indexes<span class="headerlink">&nbsp;<a href="#sparse-indexes" title="permalink">#</a></span></h2>
<p>If an item doesn't have one of the attributes
used as index partition/sort key,
it won't appear in the index
(and, you won't pay for it).
This can be used deliberately to query
only a subset of the items in the table,
like those of a specific type,
or that are in a specific state.</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p>Assuming you have dedicated album items,
an alternative way to list all the albums
is to have a GSI
with <code>{Album}</code> as partition key,
and just scan the entire index
(the primary key should be a dedicated attribute,
say <em>AlbumsGSIPK</em>,
so that only album items appear in the index;
the sort key can be any other attribute).</p>
<p>Or, to list only cover songs,
you could have dedicated GSI
with <em>CoverOfArtist</em> as primary key
and <em>Song</em> as sort key.</p>
</section>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-indexes-general-sparse-indexes.html">Sparse indexes</a></li>
</ul>
</section>
<h2 id="base-table-indexes">Base-table indexes<span class="headerlink">&nbsp;<a href="#base-table-indexes" title="permalink">#</a></span></h2>
<!-- TODO: this is not from official docs, lmk if it has a standard name -->

<p>In some cases, a global secondary index just doesn't cut it –
maybe you want to model a many-to-one mapping
(a GSI won't help here,
since it can only map one attribute in the base table
to another attribute in the index),
or you want a strongly consistent index.</p>
<p>You can maintain an index yourself in the base table,
by having additional &quot;index&quot; items associated with a &quot;main&quot; item;
this allows you to go from the main item to the &quot;index&quot; items via a normal attribute,
and from any of the &quot;index&quot; items to the main item via their partition key.
To ensure consistency when updating the mapping
you can use transactions <!-- TODO link -->
(this way, you won't get partial updates if your program crashes mid-update).</p>
<section class="admonition note">
<p class="admonition-title">Example</p>
<p>A song can have multiple identifiers in external systems,
such as <a class="external" href="https://en.wikipedia.org/wiki/International_Standard_Recording_Code"><abbr title="International Standard Recording Code">ISRC</abbr></a>, <a class="external" href="https://en.wikipedia.org/wiki/International_Standard_Musical_Work_Code"><abbr title="International Standard Musical Work Code">ISWC</abbr></a>, or <a class="external" href="https://musicbrainz.org/doc/MusicBrainz_Identifier"><abbr title="MusicBrainz Identifier">MBID</abbr></a>.
To query songs by multiple external ids,
you'd structure your database like this:</p>
<ul>
<li>song<ul>
<li>partition key <code>song#{Artist}#{Album}</code></li>
<li>sort key <code>{Song}</code></li>
<li><em>ExternalIds</em>: <code>{type: id, ...}</code></li>
</ul>
</li>
<li>external ids<ul>
<li>partition key <code>external#{type}#{id}</code></li>
<li>sort key <code>song#{Artist}#{Album}#{Song}</code></li>
</ul>
</li>
</ul>
</section>
<p>Note that modeling one-to-many relationships isn't this involved,
since it fits neatly into the different-entities-same-partition variant
of <a class="anchor" href="#single-table-design">single table design</a>.</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItemCollections.html">Working with item collections</a> (modeling one-to-many relationships)</li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-adjacency-graphs.html">Many-to-many relationships</a> ???</li>
</ul>
</section>
<h2 id="optimistic-locking">Optimistic locking<span class="headerlink">&nbsp;<a href="#optimistic-locking" title="permalink">#</a></span></h2>
<p><a class="external" href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control">Optimistic locking</a> is a concurrency control method
where you're assuming conflicts are rare,
so instead of acquiring a lock before doing your changes,
you check if the data has changed right before commiting,
as an atomic operation.</p>
<p>In DynamoDB,
that atomic operation is a <a class="internal" href="/dynamodb-model#conditional-updates">conditional update</a>.
Items have a version attribute,
and every time you want to update the item, you:</p>
<ol>
<li>read the item, including the version</li>
<li>increment the version and modify the item</li>
<li>update the item, using a condition expression to ensure the version matches<ol>
<li>if successful, you're done</li>
<li>else, start over from the beginning</li>
</ol>
</li>
</ol>
<p>Notably,
you can use this with transactions
to update groups of related items,
(like in the <a class="anchor" href="#base-table-indexes">base-table index</a> pattern above),
with only the &quot;main&quot; item requiring a version.</p>
<p>The upside of this pattern is that most of the time,
the update will succeed, which should be faster on average
(also, strongly-consistent reads can lower the chance of conflicts).
The downside is that your application needs to support this model explicitly
(it has to be possible to &quot;start over&quot;,
which can complicate the logic,
especially if besides updating the item
you're interacting with an external system,
e.g. to send a notification).</p>
<section class="admonition tip">
<p class="admonition-title">See also</p>
<ul>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/BestPractices_ImplementingVersionControl.html">Implementing version control</a> via optimistic locking (Python example)</li>
<li><a class="external" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.OptimisticLocking.html">Optimistic locking with version number</a> (Java example)</li>
</ul>
</section>








</div>
</main>


<footer class="footer">
<p class="text-gray">
<a href="/">home</a>
∙ <a href="/_feed/index.xml">feed</a>
∙ <a href="/about">about</a>

∙ © 2021 lemon24



</footer>


</div>